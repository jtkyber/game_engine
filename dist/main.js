/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/control/app.ts":
/*!****************************!*\
  !*** ./src/control/app.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ App)\n/* harmony export */ });\n/* harmony import */ var _model_scene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/scene */ \"./src/model/scene.ts\");\n/* harmony import */ var _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view/gltf/loader */ \"./src/view/gltf/loader.ts\");\n/* harmony import */ var _view_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view/renderer */ \"./src/view/renderer.ts\");\n/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controller */ \"./src/control/controller.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass App {\n    constructor(canvas) {\n        this.showAABBs = false;\n        this.showOBBs = false;\n        this.start = () => {\n            this.then = performance.now();\n            this.startTime = this.then;\n            this.frame();\n        };\n        this.frame = () => {\n            requestAnimationFrame(this.frame);\n            this.now = performance.now();\n            window.myLib.deltaTime = this.now - this.then;\n            this.then = performance.now();\n            this.controller.update();\n            this.scene.update();\n            this.renderer.render(this.scene.get_render_data(), this.scene.modelNodeChunks, this.scene.models);\n            this.framerateChunk.push(window.myLib.deltaTime);\n            if (this.framerateChunk.length === this.framesPerFPSupdate)\n                this.show_framerate();\n        };\n        this.canvas = canvas;\n        this.framerateChunk = [];\n        this.framesPerFPSupdate = 10;\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            window.myLib = window.myLib || {};\n            window.myLib.deltaTime = 0;\n            this.renderer = new _view_renderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.canvas);\n            yield this.renderer.setupDevice();\n            const gltfLoader = new _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.renderer.device);\n            yield gltfLoader.parse_gltf('dist/scene');\n            const gltfScene = gltfLoader.load_scene(0);\n            // console.log(nodes);\n            // console.log(animations);\n            this.scene = new _model_scene__WEBPACK_IMPORTED_MODULE_0__[\"default\"](_view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes, gltfScene.modelNodeChunks, this.renderer.device, gltfLoader.allJoints);\n            this.scene.set_models(gltfScene.models, gltfScene.player);\n            this.renderer.init();\n            this.controller = new _controller__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.canvas, this.scene.camera, this.scene.player);\n        });\n    }\n    show_framerate() {\n        let averageDeltaTime = 0;\n        for (let i = 0; i < this.framesPerFPSupdate; i++) {\n            averageDeltaTime += this.framerateChunk[i];\n        }\n        averageDeltaTime /= this.framesPerFPSupdate;\n        document.getElementById('fps_counter').innerText = (~~(1000 / averageDeltaTime)).toString();\n        this.framerateChunk = [];\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/control/app.ts?");

/***/ }),

/***/ "./src/control/controller.ts":
/*!***********************************!*\
  !*** ./src/control/controller.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Controller)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/gltf/loader */ \"./src/view/gltf/loader.ts\");\n\n\nclass Controller {\n    constructor(canvas, camera, player) {\n        this.moveVec = [0, 0];\n        this.controlBoard = {\n            f: 0,\n            b: 0,\n            l: 0,\n            r: 0,\n            space: 0,\n        };\n        this.canvas = canvas;\n        this.camera = camera;\n        this.player = player;\n        this.spinInterpolationCoefficient = 0;\n        this.scrollInterpolationCoefficient = 0;\n        document.addEventListener('keydown', e => this.handleKeyDown(e));\n        document.addEventListener('keyup', e => this.handleKeyUp(e));\n        document.addEventListener('mousemove', e => this.handleMouseMove(e));\n        document.addEventListener('mousedown', () => this.handleMouseDown());\n        canvas.addEventListener('wheel', e => this.handleScrollWheel(e), { passive: true });\n        document.addEventListener('pointerlockchange', () => {\n            if (document.pointerLockElement === canvas) {\n                this.pointerLocked = true;\n            }\n            else\n                this.pointerLocked = false;\n        }, false);\n    }\n    update() {\n        this.scrollInterpolationCoefficient += 0.01;\n        this.spinInterpolationCoefficient += 0.01;\n        this.moveVec[0] = this.controlBoard.f - this.controlBoard.b;\n        this.moveVec[1] = this.controlBoard.r - this.controlBoard.l;\n        if (this.moveVec[0] !== 0 || this.moveVec[1] !== 0) {\n            const endDir = this.get_rotated_direction_with_forward(this.camera.forwardMove);\n            this.player.spin_lerp(endDir);\n            this.player.move(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.mulScalar(this.player.forwardMove, -1), this.player.speed);\n        }\n        this.camera.lerp_cam_dist(this.scrollInterpolationCoefficient);\n        if (this.controlBoard.space) {\n            _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.animations['spider basic'].play();\n        }\n    }\n    get_rotated_direction_with_forward(forward) {\n        let newDir;\n        const rotationAxis = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(0, 1, 0);\n        switch (this.moveVec.toString()) {\n            case '0,0':\n                // Still\n                return;\n            case '1,0':\n                // Forward\n                newDir = forward;\n                break;\n            case '-1,0':\n                // Backward\n                newDir = this.dir_rotated(forward, Math.PI, rotationAxis);\n                break;\n            case '0,1':\n                // Right\n                newDir = this.dir_rotated(forward, -Math.PI / 2, rotationAxis);\n                break;\n            case '0,-1':\n                // Left\n                newDir = this.dir_rotated(forward, Math.PI / 2, rotationAxis);\n                break;\n            case '1,1':\n                // Forward-Right\n                newDir = this.dir_rotated(forward, -Math.PI / 4, rotationAxis);\n                break;\n            case '1,-1':\n                // Forward-Left\n                newDir = this.dir_rotated(forward, Math.PI / 4, rotationAxis);\n                break;\n            case '-1,1':\n                // Backward-Right\n                newDir = this.dir_rotated(forward, Math.PI + Math.PI / 4, rotationAxis);\n                break;\n            case '-1,-1':\n                // Backward-Left\n                newDir = this.dir_rotated(forward, -(Math.PI + Math.PI / 4), rotationAxis);\n                break;\n        }\n        return newDir;\n    }\n    dir_rotated(dir, angle, axis) {\n        const chunk1 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.mulScalar(dir, Math.cos(angle));\n        const chunk2 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.mulScalar(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(axis, dir), Math.sin(angle));\n        const chunk3 = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.mulScalar(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.mulScalar(axis, wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.dot(axis, dir)), 1 - Math.cos(angle));\n        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(chunk1, wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(chunk2, chunk3));\n    }\n    handleKeyDown(e) {\n        if (!this.pointerLocked)\n            return;\n        switch (e.code) {\n            case 'KeyW':\n                if (this.controlBoard.f)\n                    return;\n                this.controlBoard.f = 1;\n                break;\n            case 'KeyS':\n                if (this.controlBoard.b)\n                    return;\n                this.controlBoard.b = 1;\n                break;\n            case 'KeyA':\n                if (this.controlBoard.l)\n                    return;\n                this.controlBoard.l = 1;\n                break;\n            case 'KeyD':\n                if (this.controlBoard.r)\n                    return;\n                this.controlBoard.r = 1;\n                break;\n            case 'Space':\n                if (this.controlBoard.space)\n                    return;\n                this.controlBoard.space = 1;\n                break;\n        }\n    }\n    handleKeyUp(e) {\n        if (!this.pointerLocked)\n            return;\n        switch (e.code) {\n            case 'KeyW':\n                this.controlBoard.f = 0;\n                break;\n            case 'KeyS':\n                this.controlBoard.b = 0;\n                break;\n            case 'KeyA':\n                this.controlBoard.l = 0;\n                break;\n            case 'KeyD':\n                this.controlBoard.r = 0;\n                break;\n            case 'Space':\n                this.controlBoard.space = 0;\n                _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.animations['spider basic'].reset();\n                break;\n        }\n    }\n    handleMouseMove(e) {\n        if (!this.pointerLocked)\n            return;\n        this.camera.yaw -= e.movementX * 0.0005;\n        this.camera.pitch -= e.movementY * 0.0005;\n    }\n    handleMouseDown() {\n        if (!this.pointerLocked) {\n            this.lockPointer();\n        }\n        else {\n        }\n    }\n    handleScrollWheel(e) {\n        if (!this.pointerLocked)\n            return;\n        this.scrollInterpolationCoefficient = 0;\n        this.camera.camDistLerpInc = e.deltaY / 30;\n        this.camera.distFromModelStart = this.camera.distFromModel;\n    }\n    lockPointer() {\n        if (document.pointerLockElement !== this.canvas) {\n            this.canvas.requestPointerLock =\n                this.canvas.requestPointerLock ||\n                    //@ts-expect-error\n                    this.canvas.mozRequestPointerLock ||\n                    //@ts-expect-error\n                    this.canvas.webkitRequestPointerLock;\n            //@ts-expect-error\n            const promise = this.canvas.requestPointerLock({ unadjustedMovement: true });\n            //@ts-expect-error\n            if (!promise) {\n                console.log('Disabling mouse acceleration is not supported');\n                return this.canvas.requestPointerLock();\n            }\n            return (promise\n                //@ts-expect-error\n                .then(() => console.log('Pointer is locked'))\n                //@ts-expect-error\n                .catch(err => {\n                if (err.name === 'NotSupportedError') {\n                    return this.canvas.requestPointerLock();\n                }\n            }));\n        }\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/control/controller.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _control_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./control/app */ \"./src/control/app.ts\");\n\nif (!navigator.gpu)\n    throw new Error('WebGPU not supported on this browser');\nconst canvas = document.getElementById('canvas');\nconst app = new _control_app__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas);\napp.init().then(app.start);\n\n\n//# sourceURL=webpack://game_engine/./src/index.ts?");

/***/ }),

/***/ "./src/model/camera.ts":
/*!*****************************!*\
  !*** ./src/model/camera.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/gltf/loader */ \"./src/view/gltf/loader.ts\");\n\n\nclass Camera {\n    constructor(targetModel) {\n        this.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(0, 0, 0);\n        this.quat = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.quat.create(0, 0, 0, 1);\n        this.forward = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.forwardMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.rightMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.target = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create();\n        this.distAboveModel = 1.5;\n        this.distFromModelStart = 8;\n        this.distFromModel = 8;\n        this.distFromModelMin = 1.5;\n        this.distFromModelMax = 20;\n        this.camDistLerpInc = 0;\n        this.pitch = 0;\n        this.yaw = 0;\n        this.targetModel = targetModel;\n    }\n    update() {\n        this.pitch = Math.min(Math.PI / 2 - 0.1, Math.max(-Math.PI / 2 + 0.1, this.pitch));\n        // Move camera to center of model\n        this.position[0] = _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[this.targetModel.nodeIndex].position[0];\n        this.position[1] = _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[this.targetModel.nodeIndex].position[1] + this.distAboveModel;\n        this.position[2] = _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[this.targetModel.nodeIndex].position[2];\n        // Make quat from pitch and yaw\n        this.quat = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.quat.fromEuler(this.pitch, this.yaw, 0, 'yxz');\n        // Get direction vectors\n        this.forward = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.transformQuat([0, 0, -1], this.quat));\n        this.forwardMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(this.forward[0], 0, this.forward[2]));\n        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(this.forward, [0, 1, 0]));\n        this.rightMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.create(this.right[0], 0, this.right[2]));\n        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.cross(this.right, this.forward));\n        // Move camera back out along forward vector\n        this.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.addScaled(this.position, this.forward, -this.distFromModel);\n        // Don't let camera clip through ground\n        if (this.position[1] < 0.1)\n            this.position[1] = 0.1;\n        // Get position to look at\n        this.target = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.add(this.position, this.forward);\n        // Create view matrix\n        this.view = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.mat4.lookAt(this.position, this.target, [0, 1, 0]);\n    }\n    move_FB(sign, amt) {\n        const moveAmt = sign * amt * window.myLib.deltaTime;\n        this.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.addScaled(this.position, this.forwardMove, moveAmt);\n    }\n    strafe(sign, amt) {\n        const moveAmt = sign * amt * window.myLib.deltaTime;\n        this.position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.addScaled(this.position, this.rightMove, moveAmt);\n    }\n    lerp_cam_dist(lerpVal) {\n        const lerpAmt = lerpVal * window.myLib.deltaTime * 0.5;\n        if (lerpAmt >= 1 || lerpAmt <= -1)\n            return;\n        this.distFromModel = this.distFromModelStart + lerpAmt * this.camDistLerpInc;\n        if (this.distFromModel < this.distFromModelMin)\n            this.distFromModel = this.distFromModelMin;\n        if (this.distFromModel > this.distFromModelMax)\n            this.distFromModel = this.distFromModelMax;\n    }\n    get_view() {\n        return this.view;\n    }\n    get_position() {\n        return this.position;\n    }\n    get_forward() {\n        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_1__.vec3.mulScalar(this.forward, -1);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/model/camera.ts?");

/***/ }),

/***/ "./src/model/light.ts":
/*!****************************!*\
  !*** ./src/model/light.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Light)\n/* harmony export */ });\nclass Light {\n    constructor(name, type, intensity, color, innerConeAngle, outerConeAngle, nodeIndex) {\n        this.name = name;\n        this.type = type;\n        this.intensity = intensity;\n        this.color = color;\n        this.innerConeAngle = innerConeAngle;\n        this.outerConeAngle = outerConeAngle;\n        this.nodeIndex = nodeIndex;\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/model/light.ts?");

/***/ }),

/***/ "./src/model/model.ts":
/*!****************************!*\
  !*** ./src/model/model.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/enums */ \"./src/types/enums.ts\");\n/* harmony import */ var _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view/gltf/loader */ \"./src/view/gltf/loader.ts\");\n\n\n\nclass Model {\n    constructor(name, moveableFlag, nodeIndex) {\n        this.speed = 0.005;\n        this.turnSpeed = 0;\n        this.name = name;\n        this.moveableFlag = moveableFlag;\n        this.nodeIndex = nodeIndex;\n    }\n    update() {\n        if (this.moveableFlag === _types_enums__WEBPACK_IMPORTED_MODULE_0__.moveableFlag.STATIC ||\n            (this.moveableFlag === _types_enums__WEBPACK_IMPORTED_MODULE_0__.moveableFlag.MOVEABLE_ROOT && _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.nodeIndex].parent !== null)) {\n            return;\n        }\n        this.forward = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.transformQuat([0, 0, -1], _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.nodeIndex].quat));\n        this.forwardMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create(this.forward[0], 0, this.forward[2]));\n        this.right = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.cross(this.forward, [0, 1, 0]));\n        this.rightMove = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.create(this.right[0], 0, this.right[2]));\n        this.up = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.normalize(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.cross(this.right, this.forward));\n    }\n    spin(rotationAxis, angleOfRotationInc) {\n        angleOfRotationInc *= window.myLib.deltaTime;\n        let angleOfRotation = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.quat.toAxisAngle(_view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.nodeIndex].quat).angle + wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.utils.degToRad(angleOfRotationInc);\n        angleOfRotation = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.utils.euclideanModulo(angleOfRotation, 2 * Math.PI);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.quat.fromAxisAngle(rotationAxis, angleOfRotation, _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.nodeIndex].quat);\n    }\n    move(dir, amt) {\n        amt *= window.myLib.deltaTime;\n        _view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.nodeIndex].position = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.addScaled(_view_gltf_loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.nodeIndex].position, dir, amt);\n    }\n    get_forward() {\n        return wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.mulScalar(this.forward, -1);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/model/model.ts?");

/***/ }),

/***/ "./src/model/player.ts":
/*!*****************************!*\
  !*** ./src/model/player.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/gltf/loader */ \"./src/view/gltf/loader.ts\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model */ \"./src/model/model.ts\");\n\n\n\nclass Player extends _model__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(name, moveableFlag, nodeIndex) {\n        super(name, moveableFlag, nodeIndex);\n        this.parent = null;\n        this.speed = 0.01;\n        this.turnSpeed = 0.015;\n    }\n    spin_lerp(endDir) {\n        let spinAmt = this.turnSpeed * window.myLib.deltaTime;\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.mulScalar(endDir, -1, endDir);\n        const sign = -Math.sign(wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.cross(endDir, this.forwardMove)[1]);\n        const angleToTurn = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.angle(endDir, this.forwardMove);\n        if (angleToTurn <= spinAmt + 1)\n            spinAmt *= angleToTurn * 0.8;\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.quat.rotateY(_view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[this.nodeIndex].quat, sign * spinAmt, _view_gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[this.nodeIndex].quat);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/model/player.ts?");

/***/ }),

/***/ "./src/model/scene.ts":
/*!****************************!*\
  !*** ./src/model/scene.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/enums */ \"./src/types/enums.ts\");\n/* harmony import */ var _view_compute_joint_matrices_joint_matrices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view/compute/joint_matrices/joint_matrices */ \"./src/view/compute/joint_matrices/joint_matrices.ts\");\n/* harmony import */ var _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view/gltf/loader */ \"./src/view/gltf/loader.ts\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./camera */ \"./src/model/camera.ts\");\n\n\n\n\n\nclass Scene {\n    constructor(nodes, modelNodeChunks, device, allJoints) {\n        this.nodes = nodes;\n        this.modelNodeChunks = modelNodeChunks;\n        this.device = device;\n        this.allJoints = allJoints;\n        this.models = [];\n        this.nodeTransforms = new Float32Array(16 * this.nodes.length);\n        this.normalTransforms = new Float32Array(16 * this.nodes.length);\n        this.jointMatricesBufferList = [];\n        this.jointMatrixCompute = new _view_compute_joint_matrices_joint_matrices__WEBPACK_IMPORTED_MODULE_1__[\"default\"](device);\n    }\n    update() {\n        this.camera.update();\n        this.update_models();\n        for (let i = 0; i < _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes.length; i++) {\n            const node = _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes[i];\n            node.update();\n            const modelMatrix = this.get_node_transform(i, node.transform);\n            for (let j = 0; j < 16; j++) {\n                this.nodeTransforms[i * 16 + j] = modelMatrix[j];\n            }\n            const normalMatrix = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.transpose(wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.invert(modelMatrix));\n            for (let j = 0; j < 16; j++) {\n                this.normalTransforms[i * 16 + j] = normalMatrix[j];\n            }\n        }\n        this.jointMatricesBufferList = this.jointMatrixCompute.get_joint_matrices(this.models, this.nodeTransforms);\n        this.sortTransparent();\n    }\n    update_models() {\n        for (let i = 0; i < this.models.length; i++) {\n            const model = this.models[i];\n            model.update();\n        }\n    }\n    get_node_transform(nodeIndex, transform) {\n        var _a;\n        const node = _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes[nodeIndex];\n        const parent = (_a = node === null || node === void 0 ? void 0 : node.parent) !== null && _a !== void 0 ? _a : null;\n        const isJoint = this.allJoints.has(nodeIndex);\n        const parentIsJoint = this.allJoints.has(parent);\n        if (isJoint && !parentIsJoint) {\n            return transform;\n        }\n        else if (parent === null) {\n            // If root node\n            return transform;\n        }\n        else if (node.flag === _types_enums__WEBPACK_IMPORTED_MODULE_0__.moveableFlag.STATIC) {\n            // Never moves, so just return pre-multiplied matrix\n            return transform;\n        }\n        else if (node.flag === _types_enums__WEBPACK_IMPORTED_MODULE_0__.moveableFlag.MOVEABLE_ROOT) {\n            // Only moves as single chunk, so multiply by root\n            // Non-root nodes pre-multiplied\n            const parentMat = this.get_root_matrix(node.parent);\n            return wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.mul(parentMat, transform);\n        }\n        else {\n            // Any part can move, so muliply all nodes by parent\n            const combinedTransform = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.mul(_view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes[parent].transform, transform);\n            return this.get_node_transform(parent, combinedTransform);\n        }\n    }\n    get_root_matrix(nodeIndex) {\n        const n = _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes[nodeIndex];\n        if (n.parent === null)\n            return n.transform;\n        return this.get_root_matrix(n.parent);\n    }\n    sortTransparent() {\n        this.modelNodeChunks.transparent = this.modelNodeChunks.transparent.sort((a, b) => {\n            const nodeAdist = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.dist(this.camera.position, _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes[this.models[a.nodeIndex].nodeIndex].position);\n            const nodeBdist = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.vec3.dist(this.camera.position, _view_gltf_loader__WEBPACK_IMPORTED_MODULE_2__.nodes[this.models[b.nodeIndex].nodeIndex].position);\n            return nodeBdist - nodeAdist;\n        });\n    }\n    set_models(models, player) {\n        this.models = models;\n        this.player = player;\n        this.camera = new _camera__WEBPACK_IMPORTED_MODULE_3__.Camera(this.player);\n    }\n    get_render_data() {\n        return {\n            viewTransform: this.camera.get_view(),\n            nodeTransforms: this.nodeTransforms,\n            normalTransforms: this.normalTransforms,\n            jointMatricesBufferList: this.jointMatricesBufferList,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/model/scene.ts?");

/***/ }),

/***/ "./src/types/enums.ts":
/*!****************************!*\
  !*** ./src/types/enums.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFAnimationInterpolation: () => (/* binding */ GLTFAnimationInterpolation),\n/* harmony export */   GLTFAnimationPath: () => (/* binding */ GLTFAnimationPath),\n/* harmony export */   GLTFComponentType: () => (/* binding */ GLTFComponentType),\n/* harmony export */   GLTFRenderMode: () => (/* binding */ GLTFRenderMode),\n/* harmony export */   GLTFTextureFilter: () => (/* binding */ GLTFTextureFilter),\n/* harmony export */   GLTFTextureWrap: () => (/* binding */ GLTFTextureWrap),\n/* harmony export */   GLTFType: () => (/* binding */ GLTFType),\n/* harmony export */   ImageUsage: () => (/* binding */ ImageUsage),\n/* harmony export */   moveableFlag: () => (/* binding */ moveableFlag)\n/* harmony export */ });\nvar GLTFType;\n(function (GLTFType) {\n    GLTFType[GLTFType[\"SCALAR\"] = 0] = \"SCALAR\";\n    GLTFType[GLTFType[\"VEC2\"] = 1] = \"VEC2\";\n    GLTFType[GLTFType[\"VEC3\"] = 2] = \"VEC3\";\n    GLTFType[GLTFType[\"VEC4\"] = 3] = \"VEC4\";\n    GLTFType[GLTFType[\"MAT2\"] = 4] = \"MAT2\";\n    GLTFType[GLTFType[\"MAT3\"] = 5] = \"MAT3\";\n    GLTFType[GLTFType[\"MAT4\"] = 6] = \"MAT4\";\n})(GLTFType || (GLTFType = {}));\nvar GLTFComponentType;\n(function (GLTFComponentType) {\n    GLTFComponentType[GLTFComponentType[\"BYTE\"] = 5120] = \"BYTE\";\n    GLTFComponentType[GLTFComponentType[\"UNSIGNED_BYTE\"] = 5121] = \"UNSIGNED_BYTE\";\n    GLTFComponentType[GLTFComponentType[\"SHORT\"] = 5122] = \"SHORT\";\n    GLTFComponentType[GLTFComponentType[\"UNSIGNED_SHORT\"] = 5123] = \"UNSIGNED_SHORT\";\n    GLTFComponentType[GLTFComponentType[\"INT\"] = 5124] = \"INT\";\n    GLTFComponentType[GLTFComponentType[\"UNSIGNED_INT\"] = 5125] = \"UNSIGNED_INT\";\n    GLTFComponentType[GLTFComponentType[\"FLOAT\"] = 5126] = \"FLOAT\";\n    GLTFComponentType[GLTFComponentType[\"DOUBLE\"] = 5130] = \"DOUBLE\";\n})(GLTFComponentType || (GLTFComponentType = {}));\nvar GLTFRenderMode;\n(function (GLTFRenderMode) {\n    GLTFRenderMode[GLTFRenderMode[\"POINTS\"] = 0] = \"POINTS\";\n    GLTFRenderMode[GLTFRenderMode[\"LINE\"] = 1] = \"LINE\";\n    GLTFRenderMode[GLTFRenderMode[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n    GLTFRenderMode[GLTFRenderMode[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n    GLTFRenderMode[GLTFRenderMode[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n    GLTFRenderMode[GLTFRenderMode[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n    // Note: fans are not supported in WebGPU, use should be\n    // an error or converted into a list/strip\n    GLTFRenderMode[GLTFRenderMode[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(GLTFRenderMode || (GLTFRenderMode = {}));\nvar GLTFTextureFilter;\n(function (GLTFTextureFilter) {\n    GLTFTextureFilter[GLTFTextureFilter[\"NEAREST\"] = 9728] = \"NEAREST\";\n    GLTFTextureFilter[GLTFTextureFilter[\"LINEAR\"] = 9729] = \"LINEAR\";\n    GLTFTextureFilter[GLTFTextureFilter[\"NEAREST_MIPMAP_NEAREST\"] = 9984] = \"NEAREST_MIPMAP_NEAREST\";\n    GLTFTextureFilter[GLTFTextureFilter[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n    GLTFTextureFilter[GLTFTextureFilter[\"NEAREST_MIPMAP_LINEAR\"] = 9986] = \"NEAREST_MIPMAP_LINEAR\";\n    GLTFTextureFilter[GLTFTextureFilter[\"LINEAR_MIPMAP_LINEAR\"] = 9987] = \"LINEAR_MIPMAP_LINEAR\";\n})(GLTFTextureFilter || (GLTFTextureFilter = {}));\nvar GLTFTextureWrap;\n(function (GLTFTextureWrap) {\n    GLTFTextureWrap[GLTFTextureWrap[\"REPEAT\"] = 10497] = \"REPEAT\";\n    GLTFTextureWrap[GLTFTextureWrap[\"CLAMP_TO_EDGE\"] = 33071] = \"CLAMP_TO_EDGE\";\n    GLTFTextureWrap[GLTFTextureWrap[\"MIRRORED_REPEAT\"] = 33648] = \"MIRRORED_REPEAT\";\n})(GLTFTextureWrap || (GLTFTextureWrap = {}));\nvar ImageUsage;\n(function (ImageUsage) {\n    ImageUsage[ImageUsage[\"BASE_COLOR\"] = 0] = \"BASE_COLOR\";\n    ImageUsage[ImageUsage[\"METALLIC_ROUGHNESS\"] = 1] = \"METALLIC_ROUGHNESS\";\n    ImageUsage[ImageUsage[\"NORMAL\"] = 2] = \"NORMAL\";\n    ImageUsage[ImageUsage[\"OCCLUSION\"] = 3] = \"OCCLUSION\";\n    ImageUsage[ImageUsage[\"EMISSION\"] = 4] = \"EMISSION\";\n})(ImageUsage || (ImageUsage = {}));\nvar moveableFlag;\n(function (moveableFlag) {\n    moveableFlag[moveableFlag[\"STATIC\"] = 0] = \"STATIC\";\n    moveableFlag[moveableFlag[\"MOVEABLE_ROOT\"] = 1] = \"MOVEABLE_ROOT\";\n})(moveableFlag || (moveableFlag = {}));\nvar GLTFAnimationInterpolation;\n(function (GLTFAnimationInterpolation) {\n    GLTFAnimationInterpolation[GLTFAnimationInterpolation[\"LINEAR\"] = 0] = \"LINEAR\";\n    GLTFAnimationInterpolation[GLTFAnimationInterpolation[\"STEP\"] = 1] = \"STEP\";\n    GLTFAnimationInterpolation[GLTFAnimationInterpolation[\"CUBICSPLINE\"] = 2] = \"CUBICSPLINE\";\n})(GLTFAnimationInterpolation || (GLTFAnimationInterpolation = {}));\nvar GLTFAnimationPath;\n(function (GLTFAnimationPath) {\n    GLTFAnimationPath[GLTFAnimationPath[\"TRANSLATION\"] = 0] = \"TRANSLATION\";\n    GLTFAnimationPath[GLTFAnimationPath[\"ROTATION\"] = 1] = \"ROTATION\";\n    GLTFAnimationPath[GLTFAnimationPath[\"SCALE\"] = 2] = \"SCALE\";\n    GLTFAnimationPath[GLTFAnimationPath[\"WEIGHTS\"] = 3] = \"WEIGHTS\";\n})(GLTFAnimationPath || (GLTFAnimationPath = {}));\n\n\n//# sourceURL=webpack://game_engine/./src/types/enums.ts?");

/***/ }),

/***/ "./src/types/gltf.ts":
/*!***************************!*\
  !*** ./src/types/gltf.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   elementCountFromGLTFtype: () => (/* binding */ elementCountFromGLTFtype),\n/* harmony export */   gltfAddressMode: () => (/* binding */ gltfAddressMode),\n/* harmony export */   gltfTextureFilterMode: () => (/* binding */ gltfTextureFilterMode),\n/* harmony export */   gltfTextureMipMapMode: () => (/* binding */ gltfTextureMipMapMode),\n/* harmony export */   typedArrayFromComponentType: () => (/* binding */ typedArrayFromComponentType)\n/* harmony export */ });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ \"./src/types/enums.ts\");\n\nfunction gltfTextureFilterMode(filter) {\n    switch (filter) {\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_NEAREST:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_LINEAR:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST:\n            return 'nearest';\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_NEAREST:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_LINEAR:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR:\n            return 'linear';\n    }\n}\nfunction gltfTextureMipMapMode(filter) {\n    switch (filter) {\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_NEAREST:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_NEAREST:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST:\n            return 'nearest';\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR_MIPMAP_LINEAR:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.NEAREST_MIPMAP_LINEAR:\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureFilter.LINEAR:\n            return 'linear';\n    }\n}\nfunction gltfAddressMode(mode) {\n    switch (mode) {\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.REPEAT:\n            return 'repeat';\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.CLAMP_TO_EDGE:\n            return 'clamp-to-edge';\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFTextureWrap.MIRRORED_REPEAT:\n            return 'mirror-repeat';\n    }\n}\nfunction typedArrayFromComponentType(componentType) {\n    switch (componentType) {\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.BYTE:\n            return Int8Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_BYTE:\n            return Uint8Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.SHORT:\n            return Int16Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_SHORT:\n            return Uint16Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.INT:\n            return Int32Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_INT:\n            return Uint32Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.FLOAT:\n            return Float32Array;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.DOUBLE:\n            return Float64Array;\n    }\n}\nfunction elementCountFromGLTFtype(type) {\n    switch (type) {\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.SCALAR:\n            return 1;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC2:\n            return 2;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC3:\n            return 3;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC4:\n            return 4;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT2:\n            return 4;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT3:\n            return 9;\n        case _enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT4:\n            return 16;\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/types/gltf.ts?");

/***/ }),

/***/ "./src/types/types.ts":
/*!****************************!*\
  !*** ./src/types/types.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMoveableFlagType: () => (/* binding */ getMoveableFlagType)\n/* harmony export */ });\n/* harmony import */ var _enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums */ \"./src/types/enums.ts\");\n\nfunction getMoveableFlagType(name) {\n    switch (name) {\n        case 'static':\n            return _enums__WEBPACK_IMPORTED_MODULE_0__.moveableFlag.STATIC;\n        case 'moveableRoot':\n            return _enums__WEBPACK_IMPORTED_MODULE_0__.moveableFlag.MOVEABLE_ROOT;\n        default:\n            return null;\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/types/types.ts?");

/***/ }),

/***/ "./src/utils/gltf.ts":
/*!***************************!*\
  !*** ./src/utils/gltf.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gltfTypeNumComponents: () => (/* binding */ gltfTypeNumComponents),\n/* harmony export */   gltfTypeSize: () => (/* binding */ gltfTypeSize),\n/* harmony export */   gltfVertexType: () => (/* binding */ gltfVertexType),\n/* harmony export */   parseGltfType: () => (/* binding */ parseGltfType)\n/* harmony export */ });\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/enums */ \"./src/types/enums.ts\");\n\nfunction parseGltfType(type) {\n    switch (type) {\n        case 'SCALAR':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.SCALAR;\n        case 'VEC2':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC2;\n        case 'VEC3':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC3;\n        case 'VEC4':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC4;\n        case 'MAT2':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT2;\n        case 'MAT3':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT3;\n        case 'MAT4':\n            return _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT4;\n        default:\n            throw Error(`Unhandled glTF Type ${type}`);\n    }\n}\nfunction gltfTypeSize(componentType, type) {\n    let componentSize = 0;\n    switch (componentType) {\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.BYTE:\n            componentSize = 1;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_BYTE:\n            componentSize = 1;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.SHORT:\n            componentSize = 2;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_SHORT:\n            componentSize = 2;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.INT:\n            componentSize = 4;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_INT:\n            componentSize = 4;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.FLOAT:\n            componentSize = 4;\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.DOUBLE:\n            componentSize = 8;\n            break;\n        default:\n            throw Error('Unrecognized GLTF Component Type?');\n    }\n    return gltfTypeNumComponents(type) * componentSize;\n}\nfunction gltfTypeNumComponents(type) {\n    switch (type) {\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.SCALAR:\n            return 1;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC2:\n            return 2;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC3:\n            return 3;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.VEC4:\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT2:\n            return 4;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT3:\n            return 9;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFType.MAT4:\n            return 16;\n        default:\n            throw Error(`Invalid glTF Type ${type}`);\n    }\n}\nfunction gltfVertexType(componentType, type) {\n    var typeStr = null;\n    switch (componentType) {\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.BYTE:\n            typeStr = 'sint8';\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_BYTE:\n            typeStr = 'uint8';\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.SHORT:\n            typeStr = 'sint16';\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_SHORT:\n            typeStr = 'uint16';\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.INT:\n            typeStr = 'int32';\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.UNSIGNED_INT:\n            typeStr = 'uint32';\n            break;\n        case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFComponentType.FLOAT:\n            typeStr = 'float32';\n            break;\n        default:\n            throw Error(`Unrecognized or unsupported glTF type ${componentType}`);\n    }\n    switch (gltfTypeNumComponents(type)) {\n        case 1:\n            return typeStr;\n        case 2:\n            return typeStr + 'x2';\n        case 3:\n            return typeStr + 'x3';\n        case 4:\n            return typeStr + 'x4';\n        default:\n            throw Error(`Invalid number of components for gltfType: ${type}`);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/utils/gltf.ts?");

/***/ }),

/***/ "./src/utils/matrix.ts":
/*!*****************************!*\
  !*** ./src/utils/matrix.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRotationTranslationScale: () => (/* binding */ fromRotationTranslationScale),\n/* harmony export */   getRotation: () => (/* binding */ getRotation),\n/* harmony export */   zUpTransformation: () => (/* binding */ zUpTransformation)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n    // Quaternion math\n    let x = q[0], y = q[1], z = q[2], w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = s[0];\n    let sy = s[1];\n    let sz = s[2];\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n    return out;\n}\nfunction getRotation(mat, out) {\n    if (!out)\n        out = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.create();\n    let scaling = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create();\n    wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.getScaling(mat, scaling);\n    let is1 = 1 / scaling[0];\n    let is2 = 1 / scaling[1];\n    let is3 = 1 / scaling[2];\n    let sm11 = mat[0] * is1;\n    let sm12 = mat[1] * is2;\n    let sm13 = mat[2] * is3;\n    let sm21 = mat[4] * is1;\n    let sm22 = mat[5] * is2;\n    let sm23 = mat[6] * is3;\n    let sm31 = mat[8] * is1;\n    let sm32 = mat[9] * is2;\n    let sm33 = mat[10] * is3;\n    let trace = sm11 + sm22 + sm33;\n    let S = 0;\n    if (trace > 0) {\n        S = Math.sqrt(trace + 1.0) * 2;\n        out[3] = 0.25 * S;\n        out[0] = (sm23 - sm32) / S;\n        out[1] = (sm31 - sm13) / S;\n        out[2] = (sm12 - sm21) / S;\n    }\n    else if (sm11 > sm22 && sm11 > sm33) {\n        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n        out[3] = (sm23 - sm32) / S;\n        out[0] = 0.25 * S;\n        out[1] = (sm12 + sm21) / S;\n        out[2] = (sm31 + sm13) / S;\n    }\n    else if (sm22 > sm33) {\n        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n        out[3] = (sm31 - sm13) / S;\n        out[0] = (sm12 + sm21) / S;\n        out[1] = 0.25 * S;\n        out[2] = (sm23 + sm32) / S;\n    }\n    else {\n        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n        out[3] = (sm12 - sm21) / S;\n        out[0] = (sm31 + sm13) / S;\n        out[1] = (sm23 + sm32) / S;\n        out[2] = 0.25 * S;\n    }\n    return out;\n}\nfunction zUpTransformation() {\n    return wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\n}\n\n\n//# sourceURL=webpack://game_engine/./src/utils/matrix.ts?");

/***/ }),

/***/ "./src/view/compute/joint_matrices/joint_matrices.ts":
/*!***********************************************************!*\
  !*** ./src/view/compute/joint_matrices/joint_matrices.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JointMatrices)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _gltf_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../gltf/loader */ \"./src/view/gltf/loader.ts\");\n/* harmony import */ var _joint_matrices_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./joint_matrices.wgsl */ \"./src/view/compute/joint_matrices/joint_matrices.wgsl\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n// For single model\nclass JointMatrices {\n    constructor(device) {\n        this.jointMatricesBufferList = [];\n        this.device = device;\n        this.shaderModule = this.device.createShaderModule({ label: 'shader', code: _joint_matrices_wgsl__WEBPACK_IMPORTED_MODULE_1__[\"default\"] });\n    }\n    get_joint_matrices(models, modelTransforms) {\n        this.jointMatricesBufferList = [];\n        this.createBindGroupLayouts();\n        let count = 0;\n        for (let i = 0; i < models.length; i++) {\n            const model = models[i];\n            const node = _gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[model.nodeIndex];\n            if (!node.skin) {\n                this.jointMatricesBufferList.push(null);\n                continue;\n            }\n            this.setInverseBindMatricesForModel(node);\n            this.setInverseGlobalTransformForModel(model.nodeIndex, modelTransforms);\n            this.setGlobalJointTransformsForModel(node, modelTransforms);\n            this.resultBuffer = this.device.createBuffer({\n                label: 'resultBuffer',\n                size: 16 * 4 * node.skin.joints.length,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n            });\n            this.createBindGroup();\n            this.createPipeline();\n            this.compute();\n            count++;\n        }\n        return this.jointMatricesBufferList;\n    }\n    setInverseBindMatricesForModel(node) {\n        this.inverseBindMatricesBuffer = node.skin.inverseBindMatrices.bufferView.gpuBuffer;\n    }\n    setInverseGlobalTransformForModel(nodeIndex, modelTransforms) {\n        const globalTransform = modelTransforms.slice(16 * nodeIndex, 16 * nodeIndex + 16);\n        const inverseGlobalTransform = wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.mat4.inverse(globalTransform);\n        this.inverseGlobalTransformBuffer = this.device.createBuffer({\n            label: 'inverseGlobalTransformBuffer',\n            size: 16 * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.device.queue.writeBuffer(this.inverseGlobalTransformBuffer, 0, inverseGlobalTransform);\n    }\n    setGlobalJointTransformsForModel(node, modelTransforms) {\n        const globalJointTransformArr = new Float32Array(16 * node.skin.joints.length);\n        for (let j = 0; j < node.skin.joints.length; j++) {\n            const jointNodeIndex = node.skin.joints[j];\n            const globalJointTransform = modelTransforms.slice(16 * jointNodeIndex, 16 * jointNodeIndex + 16);\n            for (let k = 0; k < 16; k++)\n                globalJointTransformArr[j * 16 + k] = globalJointTransform[k];\n        }\n        this.globalJointTransformsBuffer = this.device.createBuffer({\n            label: 'globalJointTransformsBuffer',\n            size: globalJointTransformArr.byteLength,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.device.queue.writeBuffer(this.globalJointTransformsBuffer, 0, globalJointTransformArr);\n    }\n    createBindGroupLayouts() {\n        this.bindGroupLayout = this.device.createBindGroupLayout({\n            label: 'Joint Matrices Bind Group Layout',\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: 'storage',\n                    },\n                },\n            ],\n        });\n    }\n    createBindGroup() {\n        this.bindGroup = this.device.createBindGroup({\n            label: 'Joint Matrices Bind Group',\n            layout: this.bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.inverseBindMatricesBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.inverseGlobalTransformBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.globalJointTransformsBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: this.resultBuffer,\n                    },\n                },\n            ],\n        });\n    }\n    createPipeline() {\n        this.pipeline = this.device.createComputePipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [this.bindGroupLayout],\n            }),\n            compute: {\n                module: this.shaderModule,\n                entryPoint: 'main',\n            },\n        });\n    }\n    compute() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const commandEncoder = this.device.createCommandEncoder();\n            const computePass = commandEncoder.beginComputePass();\n            computePass.setPipeline(this.pipeline);\n            computePass.setBindGroup(0, this.bindGroup);\n            computePass.dispatchWorkgroups(64, 1, 1);\n            computePass.end();\n            const gpuReadBuffer = this.device.createBuffer({\n                size: this.resultBuffer.size,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            });\n            // const gpuReadBuffer = this.device.createBuffer({\n            // \tsize: this.resultBuffer.size,\n            // \tusage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n            // });\n            commandEncoder.copyBufferToBuffer(this.resultBuffer, 0, gpuReadBuffer, 0, this.resultBuffer.size);\n            this.device.queue.submit([commandEncoder.finish()]);\n            this.jointMatricesBufferList.push(gpuReadBuffer);\n            // await gpuReadBuffer.mapAsync(GPUMapMode.READ);\n            // const arrayBuffer = gpuReadBuffer.getMappedRange();\n            // console.log(new Float32Array(arrayBuffer));\n        });\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/compute/joint_matrices/joint_matrices.ts?");

/***/ }),

/***/ "./src/view/gltf/accessor.ts":
/*!***********************************!*\
  !*** ./src/view/gltf/accessor.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFAccessor)\n/* harmony export */ });\n/* harmony import */ var _types_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/gltf */ \"./src/types/gltf.ts\");\n/* harmony import */ var _utils_gltf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/gltf */ \"./src/utils/gltf.ts\");\n\n\nclass GLTFAccessor {\n    constructor(view, accessor) {\n        this.min = null;\n        this.max = null;\n        this.bufferView = view;\n        this.count = accessor['count'];\n        this.componentType = accessor['componentType'];\n        this.gltfType = (0,_utils_gltf__WEBPACK_IMPORTED_MODULE_1__.parseGltfType)(accessor['type']);\n        this.byteOffset = 0;\n        if (accessor['min'] && accessor['max']) {\n            this.min = accessor['min'];\n            this.max = accessor['max'];\n        }\n        if (accessor['byteOffset'] !== undefined) {\n            this.byteOffset = accessor['byteOffset'];\n        }\n    }\n    get byteStride() {\n        const elementSize = (0,_utils_gltf__WEBPACK_IMPORTED_MODULE_1__.gltfTypeSize)(this.componentType, this.gltfType);\n        return Math.max(elementSize, this.bufferView.byteStride);\n    }\n    get byteLength() {\n        return this.count * this.byteStride;\n    }\n    // Get the vertex attribute type for accessors that are used as vertex attributes\n    get elementType() {\n        return (0,_utils_gltf__WEBPACK_IMPORTED_MODULE_1__.gltfVertexType)(this.componentType, this.gltfType);\n    }\n    get elementCount() {\n        return (0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.elementCountFromGLTFtype)(this.gltfType);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/accessor.ts?");

/***/ }),

/***/ "./src/view/gltf/animation.ts":
/*!************************************!*\
  !*** ./src/view/gltf/animation.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFAnimation)\n/* harmony export */ });\nclass GLTFAnimation {\n    constructor(name, channels) {\n        this.name = name;\n        this.channels = channels;\n    }\n    play() {\n        for (let i = 0; i < this.channels.length; i++) {\n            this.channels[i].play();\n        }\n    }\n    reset() {\n        // lerp translation, rotation, scale back to starting position\n        for (let i = 0; i < this.channels.length; i++) {\n            this.channels[i].currentTime = 0;\n            this.channels[i].play();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/animation.ts?");

/***/ }),

/***/ "./src/view/gltf/animationChannel.ts":
/*!*******************************************!*\
  !*** ./src/view/gltf/animationChannel.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFAnimationChannel)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/enums */ \"./src/types/enums.ts\");\n/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader */ \"./src/view/gltf/loader.ts\");\n\n\n\nclass GLTFAnimationChannel {\n    constructor(sampler, targetNode, path) {\n        this.currentTime = 0;\n        this.animationSpeed = 0.0006;\n        this.sampler = sampler;\n        this.targetNode = targetNode;\n        this.path = path;\n    }\n    play() {\n        const min = this.sampler.min;\n        const max = this.sampler.max;\n        const times = this.sampler.input;\n        const values = this.sampler.output;\n        const currentTimeTemp = this.currentTime + this.animationSpeed * window.myLib.deltaTime;\n        if (currentTimeTemp > max)\n            this.currentTime = currentTimeTemp - max;\n        else if (currentTimeTemp < min)\n            this.currentTime = currentTimeTemp + min;\n        else\n            this.currentTime = currentTimeTemp;\n        switch (this.path) {\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationPath.TRANSLATION:\n                _loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.targetNode].position = this.get_interpolated_value(3, times, values);\n                break;\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationPath.ROTATION:\n                _loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.targetNode].quat = this.get_interpolated_value(4, times, values);\n                break;\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationPath.SCALE:\n                _loader__WEBPACK_IMPORTED_MODULE_1__.nodes[this.targetNode].scale = this.get_interpolated_value(3, times, values);\n                break;\n        }\n    }\n    get_value(values, i, componentCount) {\n        return values.slice(i * componentCount, i * componentCount + componentCount);\n    }\n    get_lerped_value(prevValue, nextValue, interpolationValue) {\n        switch (this.path) {\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationPath.TRANSLATION:\n                return wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.lerp(prevValue, nextValue, interpolationValue);\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationPath.ROTATION:\n                return wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.quat.slerp(prevValue, nextValue, interpolationValue);\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationPath.SCALE:\n                return wgpu_matrix__WEBPACK_IMPORTED_MODULE_2__.vec3.lerp(prevValue, nextValue, interpolationValue);\n        }\n    }\n    get_interpolated_value(componentCount, times, values) {\n        const interpolation = this.sampler.interpolation;\n        for (let i = 0; i < times.length; i++) {\n            const prevTime = times[i];\n            const nextTime = times[i + 1];\n            const prevValue = this.get_value(values, i, componentCount);\n            const nextValue = this.get_value(values, i + 1, componentCount);\n            if (this.currentTime >= prevTime && this.currentTime <= nextTime) {\n                switch (interpolation) {\n                    case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationInterpolation.STEP:\n                        return prevValue;\n                    case _types_enums__WEBPACK_IMPORTED_MODULE_0__.GLTFAnimationInterpolation.LINEAR:\n                        const interpolationValue = (this.currentTime - prevTime) / (nextTime - prevTime);\n                        return this.get_lerped_value(prevValue, nextValue, interpolationValue);\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/animationChannel.ts?");

/***/ }),

/***/ "./src/view/gltf/animationSampler.ts":
/*!*******************************************!*\
  !*** ./src/view/gltf/animationSampler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFAnimationSampler)\n/* harmony export */ });\n/* harmony import */ var _types_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/gltf */ \"./src/types/gltf.ts\");\n\nclass GLTFAnimationSampler {\n    constructor(input, output, interpolation) {\n        this.interpolation = interpolation;\n        input.bufferView.needsUpload = true;\n        input.bufferView.addUsage(GPUBufferUsage.STORAGE);\n        this.input = new ((0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.typedArrayFromComponentType)(input.componentType))(input.bufferView.view.buffer, input.bufferView.view.byteOffset, input.bufferView.view.byteLength / 4);\n        output.bufferView.needsUpload = true;\n        output.bufferView.addUsage(GPUBufferUsage.STORAGE);\n        this.output = new ((0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.typedArrayFromComponentType)(output.componentType))(output.bufferView.view.buffer, output.bufferView.view.byteOffset, output.bufferView.view.byteLength / 4);\n        this.min = input.min[0];\n        this.max = input.max[0];\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/animationSampler.ts?");

/***/ }),

/***/ "./src/view/gltf/buffer.ts":
/*!*********************************!*\
  !*** ./src/view/gltf/buffer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFBuffer: () => (/* binding */ GLTFBuffer)\n/* harmony export */ });\nclass GLTFBuffer {\n    constructor(buffer, offset, size) {\n        this.buffer = new Uint8Array(buffer, offset, size);\n        this.offset = offset;\n        this.size = size;\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/buffer.ts?");

/***/ }),

/***/ "./src/view/gltf/bufferView.ts":
/*!*************************************!*\
  !*** ./src/view/gltf/bufferView.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFBufferView)\n/* harmony export */ });\nclass GLTFBufferView {\n    constructor(buffer, view) {\n        this.buffer = buffer;\n        this.byteLength = view['byteLength'];\n        this.byteStride = 0;\n        if (view['byteStride'] !== undefined) {\n            this.byteStride = view['byteStride'];\n        }\n        if (view['byteOffset'] !== undefined) {\n            this.viewOffset = view['byteOffset'];\n        }\n        this.view = buffer.buffer.subarray(this.viewOffset, this.viewOffset + this.byteLength);\n        this.needsUpload = false;\n        this.gpuBuffer = null;\n        this.usage = 0;\n    }\n    addUsage(usage) {\n        this.usage = this.usage | usage;\n    }\n    alignTo(val, align) {\n        return Math.floor((val + align - 1) / align) * align;\n    }\n    upload(device) {\n        const buf = device.createBuffer({\n            label: 'Buffer View Buffer',\n            size: this.alignTo(this.view.byteLength, 4),\n            usage: this.usage,\n            mappedAtCreation: true,\n        });\n        new this.view.constructor(buf.getMappedRange()).set(this.view);\n        buf.unmap();\n        this.gpuBuffer = buf;\n        this.needsUpload = false;\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/bufferView.ts?");

/***/ }),

/***/ "./src/view/gltf/image.ts":
/*!********************************!*\
  !*** ./src/view/gltf/image.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFImage)\n/* harmony export */ });\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/enums */ \"./src/types/enums.ts\");\n\nclass GLTFImage {\n    constructor(name, bitmap) {\n        this.name = name;\n        this.bitmap = bitmap;\n    }\n    setUsage(usage) {\n        this.usage = usage;\n    }\n    upload(device) {\n        let format = 'rgba8unorm-srgb';\n        switch (this.usage) {\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.BASE_COLOR:\n                format = 'rgba8unorm-srgb';\n                break;\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.METALLIC_ROUGHNESS:\n                format = 'rgba8unorm';\n                break;\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.NORMAL:\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.OCCLUSION:\n            case _types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.EMISSION:\n                throw new Error('Unhandled image format for now, TODO!');\n        }\n        const imgSize = [this.bitmap.width, this.bitmap.height, 1];\n        this.image = device.createTexture({\n            label: 'Image Texture',\n            size: imgSize,\n            format: format,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        device.queue.copyExternalImageToTexture({ source: this.bitmap }, { texture: this.image, premultipliedAlpha: true }, imgSize);\n        this.view = this.image.createView();\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/image.ts?");

/***/ }),

/***/ "./src/view/gltf/loader.ts":
/*!*********************************!*\
  !*** ./src/view/gltf/loader.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animations: () => (/* binding */ animations),\n/* harmony export */   \"default\": () => (/* binding */ GTLFLoader),\n/* harmony export */   nodes: () => (/* binding */ nodes)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _model_light__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/light */ \"./src/model/light.ts\");\n/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/model */ \"./src/model/model.ts\");\n/* harmony import */ var _model_player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/player */ \"./src/model/player.ts\");\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../types/enums */ \"./src/types/enums.ts\");\n/* harmony import */ var _types_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../types/types */ \"./src/types/types.ts\");\n/* harmony import */ var _utils_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/matrix */ \"./src/utils/matrix.ts\");\n/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./accessor */ \"./src/view/gltf/accessor.ts\");\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./animation */ \"./src/view/gltf/animation.ts\");\n/* harmony import */ var _animationChannel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./animationChannel */ \"./src/view/gltf/animationChannel.ts\");\n/* harmony import */ var _animationSampler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./animationSampler */ \"./src/view/gltf/animationSampler.ts\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./buffer */ \"./src/view/gltf/buffer.ts\");\n/* harmony import */ var _bufferView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./bufferView */ \"./src/view/gltf/bufferView.ts\");\n/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./image */ \"./src/view/gltf/image.ts\");\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./materials */ \"./src/view/gltf/materials.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./mesh */ \"./src/view/gltf/mesh.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./node */ \"./src/view/gltf/node.ts\");\n/* harmony import */ var _primitive__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./primitive */ \"./src/view/gltf/primitive.ts\");\n/* harmony import */ var _sampler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./sampler */ \"./src/view/gltf/sampler.ts\");\n/* harmony import */ var _skin__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./skin */ \"./src/view/gltf/skin.ts\");\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./texture */ \"./src/view/gltf/texture.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst nodes = [];\nconst animations = {};\nclass GTLFLoader {\n    constructor(device) {\n        this.device = device;\n        this.bufferViews = [];\n        this.accessors = [];\n        this.images = [];\n        this.samplers = [];\n        this.textures = [];\n        this.materials = [];\n        this.primitives = [];\n        this.meshes = [];\n        this.skins = [];\n        this.lights = [];\n        this.models = [];\n        this.modelNodeChunks = {\n            opaque: [],\n            transparent: [],\n        };\n        this.indexSwapBoard = {};\n        this.allJoints = new Set();\n    }\n    parse_gltf(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const glb = yield fetch(`${url}.glb`).then(res => res.arrayBuffer());\n            yield this.validate(glb);\n        });\n    }\n    validate(buffer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const header = new Uint32Array(buffer, 0, 5);\n            // Validate glb file contains correct magic value\n            if (header[0] != 0x46546c67) {\n                throw Error('Provided file is not a glB file');\n            }\n            if (header[1] != 2) {\n                throw Error('Provided file is glTF 2.0 file');\n            }\n            // Validate that first chunk is JSON\n            if (header[4] != 0x4e4f534a) {\n                throw Error('Invalid glB: The first chunk of the glB file is not a JSON chunk!');\n            }\n            console.log('.glb file validated');\n            yield this.set_chunks(buffer, header);\n        });\n    }\n    set_chunks(buffer, header) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.jsonChunk = JSON.parse(new TextDecoder('utf-8').decode(new Uint8Array(buffer, 20, header[3])));\n            console.log(this.jsonChunk);\n            const binaryHeader = new Uint32Array(buffer, 20 + header[3], 2);\n            if (binaryHeader[1] != 0x004e4942) {\n                throw Error('Invalid glB: The second chunk of the glB file is not a binary chunk!');\n            }\n            this.binaryChunk = new _buffer__WEBPACK_IMPORTED_MODULE_10__.GLTFBuffer(buffer, 28 + header[3], binaryHeader[0]);\n            console.log('gltf json and binary extracted');\n            yield this.load_gltf_constants();\n        });\n    }\n    load_gltf_constants() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.load_buffer_views();\n            this.load_accessors();\n            yield this.load_images();\n            this.load_samplers();\n            this.load_textures();\n            this.loadMaterials();\n            this.load_skins();\n            this.load_meshes();\n            this.load_animations();\n            for (let i = 0; i < this.bufferViews.length; ++i) {\n                if (this.bufferViews[i].needsUpload) {\n                    this.bufferViews[i].upload(this.device);\n                }\n            }\n            this.images.forEach((img) => {\n                img.upload(this.device);\n            });\n            this.samplers.forEach((s) => {\n                s.create(this.device);\n            });\n            this.materials.forEach((mat) => {\n                mat.upload(this.device);\n            });\n            this.skins.forEach((skin) => {\n                skin.upload(this.device);\n            });\n        });\n    }\n    load_buffer_views() {\n        for (let i = 0; i < this.jsonChunk['bufferViews'].length; i++) {\n            const bufferView = this.jsonChunk['bufferViews'][i];\n            this.bufferViews.push(new _bufferView__WEBPACK_IMPORTED_MODULE_11__[\"default\"](this.binaryChunk, bufferView));\n        }\n        console.log('gltf buffer views loaded');\n    }\n    load_accessors() {\n        for (let i = 0; i < this.jsonChunk['accessors'].length; i++) {\n            const accessor = this.jsonChunk['accessors'][i];\n            let viewID = accessor['bufferView'];\n            this.accessors.push(new _accessor__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.bufferViews[viewID], accessor));\n        }\n        console.log('gltf accessors views loaded');\n    }\n    load_images() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.jsonChunk.images) {\n                this.images = [];\n                return;\n            }\n            for (let i = 0; i < this.jsonChunk['images'].length; i++) {\n                const img = this.jsonChunk['images'][i];\n                const bv = this.bufferViews[img['bufferView']];\n                const blob = new Blob([bv.view], { type: img['mimeType'] });\n                const bitmap = yield createImageBitmap(blob);\n                // const cvs = new OffscreenCanvas(bitmap.width, bitmap.height);\n                // const ctx = cvs.getContext('2d');\n                // ctx.drawImage(bitmap, 0, 0);\n                // const data = ctx.getImageData(0, 0, bitmap.width, bitmap.height);\n                // const alphas = [];\n                // for (let i = 3; i < data.data.length; i += 4) {\n                // \tif (data.data[i] !== 255) alphas.push(data.data[i]);\n                // }\n                // console.log(alphas);\n                this.images.push(new _image__WEBPACK_IMPORTED_MODULE_12__[\"default\"](img['name'], bitmap));\n            }\n            console.log('gltf images loaded');\n        });\n    }\n    load_samplers() {\n        if (!this.jsonChunk.samplers) {\n            this.samplers = [];\n            return;\n        }\n        for (let i = 0; i < this.jsonChunk['samplers'].length; i++) {\n            const s = this.jsonChunk['samplers'][i];\n            this.samplers.push(new _sampler__WEBPACK_IMPORTED_MODULE_17__.GLTFSampler(s['magFilter'], s['minFilter'], s['wrapS'], s['wrapT']));\n        }\n        console.log('gltf samplers loaded');\n    }\n    load_textures() {\n        var _a;\n        const defaultSampler = new _sampler__WEBPACK_IMPORTED_MODULE_17__.GLTFSampler(_types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFTextureFilter.LINEAR, _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFTextureFilter.LINEAR, _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFTextureWrap.REPEAT, _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFTextureWrap.REPEAT);\n        let usedDefaultSampler = false;\n        if (!((_a = this === null || this === void 0 ? void 0 : this.jsonChunk['textures']) === null || _a === void 0 ? void 0 : _a.length)) {\n            this.textures = [];\n            return;\n        }\n        for (let i = 0; i < this.jsonChunk['textures'].length; i++) {\n            const t = this.jsonChunk['textures'][i];\n            let sampler = null;\n            if ('sampler' in t) {\n                sampler = this.samplers[t['sampler']];\n            }\n            else {\n                sampler = defaultSampler;\n                usedDefaultSampler = true;\n            }\n            this.textures.push(new _texture__WEBPACK_IMPORTED_MODULE_19__.GLTFTexture(sampler, this.images[t['source']]));\n            new _texture__WEBPACK_IMPORTED_MODULE_19__.GLTFTexture(sampler, this.images[t['source']]);\n        }\n        if (usedDefaultSampler) {\n            this.samplers.push(defaultSampler);\n        }\n        console.log('gltf textures loaded');\n    }\n    loadMaterials() {\n        var _a, _b, _c, _d;\n        for (let m of this.jsonChunk['materials']) {\n            const pbrMR = m['pbrMetallicRoughness'];\n            // Default base color factor of 1, 1, 1\n            const baseColorFactor = (_a = pbrMR['baseColorFactor']) !== null && _a !== void 0 ? _a : [1, 1, 1, 1];\n            const metallicFactor = (_b = pbrMR['metallicFactor']) !== null && _b !== void 0 ? _b : 1;\n            const roughnessFactor = (_c = pbrMR['roughnessFactor']) !== null && _c !== void 0 ? _c : 1;\n            const alphaMode = (_d = m['alphaMode']) !== null && _d !== void 0 ? _d : null;\n            let baseColorTexture = null;\n            if ('baseColorTexture' in pbrMR) {\n                baseColorTexture = this.textures[pbrMR['baseColorTexture']['index']];\n            }\n            let metallicRoughnessTexture = null;\n            if ('metallicRoughnessTexture' in pbrMR) {\n                metallicRoughnessTexture = this.textures[pbrMR['metallicRoughnessTexture']['index']];\n            }\n            this.materials.push(new _materials__WEBPACK_IMPORTED_MODULE_13__[\"default\"](baseColorFactor, baseColorTexture, metallicFactor, roughnessFactor, metallicRoughnessTexture, alphaMode));\n        }\n        console.log('gltf materials loaded');\n    }\n    load_skins() {\n        for (let i = 0; i < this.jsonChunk['skins'].length; i++) {\n            const skin = this.jsonChunk['skins'][i];\n            const name = skin.name;\n            const inverseBindMatrices = this.accessors[skin.inverseBindMatrices];\n            const joints = [...skin['joints']];\n            this.skins.push(new _skin__WEBPACK_IMPORTED_MODULE_18__[\"default\"](name, inverseBindMatrices, joints));\n        }\n    }\n    load_meshes() {\n        for (let mesh of this.jsonChunk.meshes) {\n            let meshPrimitives = [];\n            for (let i = 0; i < mesh['primitives'].length; i++) {\n                const prim = mesh['primitives'][i];\n                let topology = prim['mode'];\n                if (topology === undefined)\n                    topology = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFRenderMode.TRIANGLES;\n                if (topology != _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFRenderMode.TRIANGLES && topology != _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFRenderMode.TRIANGLE_STRIP) {\n                    throw Error(`Unsupported primitive mode ${prim['mode']}`);\n                }\n                let indices = null;\n                if (this.jsonChunk['accessors'][prim['indices']] !== undefined) {\n                    indices = this.accessors[prim['indices']];\n                }\n                let positions = null;\n                let texcoords = null;\n                let normals = null;\n                let joints = null;\n                let weights = null;\n                let colors = null;\n                for (let attr in prim['attributes']) {\n                    let accessor = this.accessors[prim['attributes'][attr]];\n                    switch (attr) {\n                        case 'POSITION':\n                            positions = accessor;\n                            break;\n                        case 'TEXCOORD_0':\n                            texcoords = accessor;\n                            break;\n                        case 'NORMAL':\n                            normals = accessor;\n                            break;\n                        case 'JOINTS_0':\n                            joints = accessor;\n                            break;\n                        case 'WEIGHTS_0':\n                            weights = accessor;\n                            break;\n                        case 'COLOR_0':\n                            colors = accessor;\n                            break;\n                    }\n                }\n                let mat = this.materials[prim['material']];\n                meshPrimitives.push(new _primitive__WEBPACK_IMPORTED_MODULE_16__[\"default\"](mat, indices, positions, normals, colors, texcoords, joints, weights, topology));\n            }\n            this.meshes.push(new _mesh__WEBPACK_IMPORTED_MODULE_14__[\"default\"](mesh['name'], meshPrimitives));\n            this.primitives.push(...meshPrimitives);\n        }\n        console.log('gltf meshes loaded');\n    }\n    load_animations() {\n        for (let i = 0; i < this.jsonChunk['animations'].length; i++) {\n            const animation = this.jsonChunk['animations'][i];\n            const samplers = this.get_animation_samplers(animation['samplers']);\n            const channels = this.get_animation_channels(animation['channels'], samplers);\n            animations[animation['name']] = new _animation__WEBPACK_IMPORTED_MODULE_7__[\"default\"](animation['name'], channels);\n        }\n    }\n    get_animation_samplers(samplers) {\n        const allSamplers = [];\n        for (let s of samplers) {\n            const input = this.accessors[s['input']];\n            const output = this.accessors[s['output']];\n            let interpolation = null;\n            switch (s['interpolation']) {\n                case 'STEP':\n                    interpolation = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationInterpolation.STEP;\n                    break;\n                case 'LINEAR':\n                    interpolation = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationInterpolation.LINEAR;\n                    break;\n                case 'CUBICSPLINE':\n                    interpolation = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationInterpolation.CUBICSPLINE;\n                    break;\n            }\n            allSamplers.push(new _animationSampler__WEBPACK_IMPORTED_MODULE_9__[\"default\"](input, output, interpolation));\n        }\n        return allSamplers;\n    }\n    get_animation_channels(channels, samplers) {\n        const allChannels = [];\n        for (let c of channels) {\n            const sampler = samplers[c['sampler']];\n            const targetNode = c['target'].node;\n            let path = null;\n            switch (c['target']['path']) {\n                case 'translation':\n                    path = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationPath.TRANSLATION;\n                    break;\n                case 'rotation':\n                    path = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationPath.ROTATION;\n                    break;\n                case 'scale':\n                    path = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationPath.SCALE;\n                    break;\n                case 'weights':\n                    path = _types_enums__WEBPACK_IMPORTED_MODULE_3__.GLTFAnimationPath.WEIGHTS;\n                    break;\n            }\n            allChannels.push(new _animationChannel__WEBPACK_IMPORTED_MODULE_8__[\"default\"](sampler, targetNode, path));\n        }\n        return allChannels;\n    }\n    load_scene(scene_index) {\n        const scene = this.jsonChunk['scenes'][scene_index];\n        const baseNodeRefs = scene['nodes'];\n        const allNodes = this.jsonChunk['nodes'];\n        for (let i = 0; i < baseNodeRefs.length; i++) {\n            const node = allNodes[baseNodeRefs[i]];\n            let flag;\n            const lastIndex = node['name'].lastIndexOf('_');\n            flag = (0,_types_types__WEBPACK_IMPORTED_MODULE_4__.getMoveableFlagType)(node['name'].substring(lastIndex + 1));\n            if (flag !== null)\n                node['name'] = node['name'].substring(0, lastIndex);\n            this.load_nodes(allNodes, baseNodeRefs[i], flag);\n        }\n        // Pre-multiply transforms based on flag\n        for (let i = 0; i < nodes.length; i++) {\n            const modelMatrix = this.transform_matrices(nodes[i], nodes[i].transform);\n            nodes[i].transform = modelMatrix;\n        }\n        this.remap_joint_indices();\n        this.setup_models();\n        console.log('gltf nodes loaded');\n        return {\n            models: this.models,\n            player: this.player,\n            lights: this.lights,\n            modelNodeChunks: this.modelNodeChunks,\n        };\n    }\n    remap_joint_indices() {\n        for (let i = 0; i < this.skins.length; i++) {\n            for (let j = 0; j < this.skins[i].joints.length; j++) {\n                this.skins[i].joints[j] = this.indexSwapBoard[this.skins[i].joints[j]];\n                this.allJoints.add(this.skins[i].joints[j]);\n            }\n        }\n        for (let a in animations) {\n            for (let i = 0; i < animations[a].channels.length; i++) {\n                const channel = animations[a].channels[i];\n                channel.targetNode = this.indexSwapBoard[channel.targetNode];\n            }\n        }\n    }\n    load_nodes(allNodes, n, flag, parentNode = null, isRoot = true) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const node = allNodes[n];\n        const matrix = this.get_node_matrix(node);\n        let scale = (_a = node['scale']) !== null && _a !== void 0 ? _a : wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.vec3.create(1, 1, 1);\n        let rotation = (_b = node['rotation']) !== null && _b !== void 0 ? _b : wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.vec4.create(0, 0, 0, 1);\n        let translation = (_c = node['translation']) !== null && _c !== void 0 ? _c : wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.vec3.create(0, 0, 0);\n        const name = node.name;\n        const mesh = (_d = this.meshes[node['mesh']]) !== null && _d !== void 0 ? _d : null;\n        const skin = (_e = this.skins[node['skin']]) !== null && _e !== void 0 ? _e : null;\n        nodes.push(new _node__WEBPACK_IMPORTED_MODULE_15__[\"default\"](name, flag, parentNode, translation, rotation, scale, matrix, mesh, skin));\n        const lastNodeIndex = nodes.length - 1;\n        this.indexSwapBoard[n] = lastNodeIndex;\n        const lightRef = (_g = (_f = node === null || node === void 0 ? void 0 : node['extensions']) === null || _f === void 0 ? void 0 : _f['KHR_lights_punctual']) === null || _g === void 0 ? void 0 : _g['light'];\n        if (lightRef !== undefined) {\n            const lightDetails = this.jsonChunk['extensions']['KHR_lights_punctual']['lights'][lightRef];\n            const lightName = lightDetails['name'];\n            const lightType = lightDetails['type'];\n            const lightIntensity = lightDetails['intensity'];\n            const lightColor = lightDetails['color'];\n            let innerConeAngle = null;\n            let outerConeAngle = null;\n            if (lightType === 'spot') {\n                innerConeAngle = lightDetails['spot']['innerConeAngle'];\n                outerConeAngle = lightDetails['spot']['outerConeAngle'];\n            }\n            this.lights.push(new _model_light__WEBPACK_IMPORTED_MODULE_0__[\"default\"](lightName, lightType, lightIntensity, lightColor, innerConeAngle, outerConeAngle, lastNodeIndex));\n        }\n        else if (isRoot || mesh) {\n            // Is Model\n            this.models.push(new _model_model__WEBPACK_IMPORTED_MODULE_1__[\"default\"](name, flag, lastNodeIndex));\n            for (let i = 0; i < (mesh === null || mesh === void 0 ? void 0 : mesh.primitives.length); i++) {\n                const prim = mesh.primitives[i];\n                if (prim.material.isTransparent) {\n                    this.modelNodeChunks.transparent.push({ nodeIndex: lastNodeIndex, primitiveIndex: i });\n                }\n                else\n                    this.modelNodeChunks.opaque.push({ nodeIndex: lastNodeIndex, primitiveIndex: i });\n            }\n        }\n        if (node['children']) {\n            const parentNode = nodes.length - 1;\n            for (let i = 0; i < node['children'].length; i++) {\n                this.load_nodes(allNodes, node['children'][i], flag, parentNode, false);\n            }\n        }\n    }\n    setup_models() {\n        let playerFound = false;\n        for (let i = 0; i < this.models.length; i++) {\n            let model = this.models[i];\n            if (model.name === 'Player' && !playerFound) {\n                this.player = new _model_player__WEBPACK_IMPORTED_MODULE_2__[\"default\"](model.name, model.moveableFlag, model.nodeIndex);\n                this.models.splice(i, 1, this.player);\n                model = this.player;\n                playerFound = true;\n            }\n        }\n    }\n    transform_matrices(node, transform) {\n        if (node.parent === null) {\n            // If root node\n            return transform;\n        }\n        else if (node.flag === _types_enums__WEBPACK_IMPORTED_MODULE_3__.moveableFlag.STATIC) {\n            // Multiply up the parent chain, including root node\n            let parentMat = nodes[node.parent].transform;\n            const combinedTransform = wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.mat4.mul(parentMat, transform);\n            return combinedTransform;\n        }\n        else if (node.flag === _types_enums__WEBPACK_IMPORTED_MODULE_3__.moveableFlag.MOVEABLE_ROOT) {\n            // Multiply up the parent chain, excluding root node\n            if (nodes[node.parent].parent === null) {\n                // If parent is root node\n                return transform;\n            }\n            else {\n                const combinedTransform = wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.mat4.mul(nodes[node.parent].transform, transform);\n                return this.transform_matrices(nodes[node.parent], combinedTransform);\n            }\n        }\n        else {\n            // No Pre-multiplication up the parent chain\n            return transform;\n        }\n    }\n    get_node_matrix(node) {\n        if (node['matrix']) {\n            const m = node['matrix'];\n            return wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.mat4.set(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);\n        }\n        else {\n            let scale = wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.vec3.create(1, 1, 1);\n            let rotation = wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.vec4.create(0, 0, 0, 1);\n            let translation = wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.vec3.create(0, 0, 0);\n            if (node['scale']) {\n                scale = node['scale'];\n            }\n            if (node['rotation']) {\n                rotation = node['rotation'];\n            }\n            if (node['translation']) {\n                translation = node['translation'];\n            }\n            const m = wgpu_matrix__WEBPACK_IMPORTED_MODULE_20__.mat4.create();\n            return (0,_utils_matrix__WEBPACK_IMPORTED_MODULE_5__.fromRotationTranslationScale)(m, rotation, translation, scale);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/loader.ts?");

/***/ }),

/***/ "./src/view/gltf/materials.ts":
/*!************************************!*\
  !*** ./src/view/gltf/materials.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFMaterial)\n/* harmony export */ });\n/* harmony import */ var _types_enums__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/enums */ \"./src/types/enums.ts\");\n\nclass GLTFMaterial {\n    constructor(baseColorFactor, baseColorTextureView, metallicFactor, roughnessFactor, metallicRoughnessTextureView, isTransparent) {\n        this.baseColorTextureView = null; // Make texture, sampler and image classes\n        this.baseColorFactor = new Float32Array([1, 1, 1, 1]);\n        this.metallicRoughnessTextureView = null;\n        this.metallicFactor = 1;\n        this.roughnessFactor = 1;\n        this.paramBuffer = null;\n        this.bindGroupLayout = null;\n        this.bindGroup = null;\n        this.isTransparent = false;\n        this.baseColorFactor = baseColorFactor;\n        this.baseColorTextureView = baseColorTextureView;\n        if (this.baseColorTextureView) {\n            this.baseColorTextureView.setUsage(_types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.BASE_COLOR);\n        }\n        this.metallicFactor = metallicFactor;\n        this.roughnessFactor = roughnessFactor;\n        this.metallicRoughnessTextureView = metallicRoughnessTextureView;\n        if (this.metallicRoughnessTextureView) {\n            this.metallicRoughnessTextureView.setUsage(_types_enums__WEBPACK_IMPORTED_MODULE_0__.ImageUsage.METALLIC_ROUGHNESS);\n        }\n        if (isTransparent)\n            this.isTransparent = isTransparent;\n    }\n    upload(device) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.paramBuffer = device.createBuffer({\n            label: 'Material Params Buffer',\n            // We'll be passing 6 floats, which round up to 8 in UBO alignment\n            size: 8 * 4,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n            mappedAtCreation: true,\n        });\n        // Upload the factor params\n        {\n            const params = new Float32Array(this.paramBuffer.getMappedRange());\n            params.set(this.baseColorFactor, 0);\n            params.set([this.metallicFactor, this.roughnessFactor], 4);\n        }\n        this.paramBuffer.unmap();\n        this.bindGroupLayout = device.createBindGroupLayout({\n            label: 'Material Bind Group Layout',\n            entries: [\n                {\n                    // Material Params\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: 'uniform',\n                    },\n                },\n                {\n                    // Base Color Sampler\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    // Base Color Texture\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {},\n                },\n                {\n                    // Metallic Roughness Sampler\n                    binding: 3,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    // Metallic Roughness Texture\n                    binding: 4,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {},\n                },\n            ],\n        });\n        const defaultSampler = device.createSampler({\n            label: 'Default Sampler',\n            magFilter: 'linear',\n            minFilter: 'nearest',\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            // mipmapFilter: 'nearest',\n        });\n        let defaultTextureView;\n        const texture = device.createTexture({\n            label: 'Default Texture',\n            size: { width: 1, height: 1 },\n            format: 'rgba8unorm',\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        defaultTextureView = texture.createView({\n            format: 'rgba8unorm',\n            dimension: '2d',\n            aspect: 'all',\n            baseMipLevel: 0,\n            mipLevelCount: 1,\n            baseArrayLayer: 0,\n            arrayLayerCount: 1,\n        });\n        let baseColorSampler = (_b = (_a = this.baseColorTextureView) === null || _a === void 0 ? void 0 : _a.sampler) === null || _b === void 0 ? void 0 : _b.sampler;\n        if (!baseColorSampler)\n            baseColorSampler = defaultSampler;\n        let baseColorTextureView = (_d = (_c = this.baseColorTextureView) === null || _c === void 0 ? void 0 : _c.image) === null || _d === void 0 ? void 0 : _d.view;\n        if (!baseColorTextureView)\n            baseColorTextureView = defaultTextureView;\n        let metallicRoughnessSampler = (_f = (_e = this.metallicRoughnessTextureView) === null || _e === void 0 ? void 0 : _e.sampler) === null || _f === void 0 ? void 0 : _f.sampler;\n        if (!metallicRoughnessSampler)\n            metallicRoughnessSampler = defaultSampler;\n        let metallicRoughnessTextureView = (_h = (_g = this.metallicRoughnessTextureView) === null || _g === void 0 ? void 0 : _g.image) === null || _h === void 0 ? void 0 : _h.view;\n        if (!metallicRoughnessTextureView)\n            metallicRoughnessTextureView = defaultTextureView;\n        this.bindGroup = device.createBindGroup({\n            label: 'Material Bind Group',\n            layout: this.bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.paramBuffer,\n                        size: 8 * 4,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: baseColorSampler,\n                },\n                {\n                    binding: 2,\n                    resource: baseColorTextureView,\n                },\n                {\n                    binding: 3,\n                    resource: metallicRoughnessSampler,\n                },\n                {\n                    binding: 4,\n                    resource: metallicRoughnessTextureView,\n                },\n            ],\n        });\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/materials.ts?");

/***/ }),

/***/ "./src/view/gltf/mesh.ts":
/*!*******************************!*\
  !*** ./src/view/gltf/mesh.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFMesh)\n/* harmony export */ });\nclass GLTFMesh {\n    constructor(name, primitives) {\n        this.name = name;\n        this.primitives = primitives;\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/mesh.ts?");

/***/ }),

/***/ "./src/view/gltf/node.ts":
/*!*******************************!*\
  !*** ./src/view/gltf/node.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFNode)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n\nclass GLTFNode {\n    constructor(name, flag, parent, position, quat, scale, transform, mesh, skin) {\n        this.parent = null;\n        this.mesh = null;\n        this.skin = null;\n        this.name = name;\n        this.flag = flag;\n        this.parent = parent;\n        this.position = position;\n        this.quat = quat;\n        this.scale = scale;\n        this.transform = transform;\n        this.mesh = mesh;\n        this.skin = skin;\n    }\n    update() {\n        this.transform = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create();\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.translation(this.position, this.transform);\n        const rotFromQuat = wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.quat.toAxisAngle(this.quat);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.rotate(this.transform, rotFromQuat.axis, rotFromQuat.angle, this.transform);\n        wgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.scale(this.transform, this.scale, this.transform);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/node.ts?");

/***/ }),

/***/ "./src/view/gltf/primitive.ts":
/*!************************************!*\
  !*** ./src/view/gltf/primitive.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFPrimitive)\n/* harmony export */ });\nclass GLTFPrimitive {\n    constructor(material, indices, positions, normals, colors, texCoords, joints, weights, topology) {\n        this.material = null;\n        this.indices = null;\n        this.positions = null;\n        this.normals = null;\n        this.colors = null;\n        this.texCoords = null;\n        this.joints = null;\n        this.weights = null;\n        this.topology = null;\n        this.material = material;\n        this.indices = indices;\n        this.positions = positions;\n        this.normals = normals;\n        this.colors = colors;\n        this.texCoords = texCoords;\n        this.joints = joints;\n        this.weights = weights;\n        this.topology = topology;\n        this.positions.bufferView.needsUpload = true;\n        this.positions.bufferView.addUsage(GPUBufferUsage.VERTEX);\n        this.normals.bufferView.needsUpload = true;\n        this.normals.bufferView.addUsage(GPUBufferUsage.VERTEX);\n        if (this.indices) {\n            this.indices.bufferView.needsUpload = true;\n            this.indices.bufferView.addUsage(GPUBufferUsage.INDEX);\n        }\n        if (this.texCoords) {\n            this.texCoords.bufferView.needsUpload = true;\n            this.texCoords.bufferView.addUsage(GPUBufferUsage.VERTEX);\n        }\n        if (this.joints) {\n            this.joints.bufferView.needsUpload = true;\n            this.joints.bufferView.addUsage(GPUBufferUsage.VERTEX);\n        }\n        if (this.weights) {\n            this.weights.bufferView.needsUpload = true;\n            this.weights.bufferView.addUsage(GPUBufferUsage.VERTEX);\n        }\n        if (this.colors) {\n            this.colors.bufferView.needsUpload = true;\n            this.colors.bufferView.addUsage(GPUBufferUsage.VERTEX);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/primitive.ts?");

/***/ }),

/***/ "./src/view/gltf/sampler.ts":
/*!**********************************!*\
  !*** ./src/view/gltf/sampler.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFSampler: () => (/* binding */ GLTFSampler)\n/* harmony export */ });\n/* harmony import */ var _types_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/gltf */ \"./src/types/gltf.ts\");\n\nclass GLTFSampler {\n    constructor(magFilter, minFilter, wrapU, wrapV) {\n        this.magFilter = 'linear';\n        this.minFilter = 'linear';\n        this.wrapU = 'repeat';\n        this.wrapV = 'repeat';\n        this.magFilter = (0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.gltfTextureFilterMode)(magFilter) || this.magFilter;\n        this.minFilter = (0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.gltfTextureFilterMode)(minFilter) || this.minFilter;\n        this.wrapU = (0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.gltfAddressMode)(wrapU) || this.wrapU;\n        this.wrapV = (0,_types_gltf__WEBPACK_IMPORTED_MODULE_0__.gltfAddressMode)(wrapV) || this.wrapV;\n    }\n    // Create the GPU sampler\n    create(device) {\n        this.sampler = device.createSampler({\n            label: 'Sampler',\n            magFilter: this.magFilter,\n            minFilter: this.minFilter,\n            addressModeU: this.wrapU,\n            addressModeV: this.wrapV,\n            // mipmapFilter: 'nearest',\n        });\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/sampler.ts?");

/***/ }),

/***/ "./src/view/gltf/skin.ts":
/*!*******************************!*\
  !*** ./src/view/gltf/skin.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GLTFSkin)\n/* harmony export */ });\nclass GLTFSkin {\n    constructor(name, inverseBindMatrices, joints) {\n        this.name = name;\n        this.inverseBindMatrices = inverseBindMatrices;\n        this.joints = joints;\n        this.inverseBindMatrices.bufferView.needsUpload = true;\n        this.inverseBindMatrices.bufferView.addUsage(GPUBufferUsage.STORAGE);\n    }\n    upload(device) {\n        this.jointBindGroupLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    // Joint matrices\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n            ],\n        });\n        this.jointMatricesBuffer = device.createBuffer({\n            label: 'jointMatricesBuffer',\n            size: 4 * 16 * this.joints.length,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.jointBindGroup = device.createBindGroup({\n            layout: this.jointBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.jointMatricesBuffer,\n                    },\n                },\n            ],\n        });\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/skin.ts?");

/***/ }),

/***/ "./src/view/gltf/texture.ts":
/*!**********************************!*\
  !*** ./src/view/gltf/texture.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFTexture: () => (/* binding */ GLTFTexture)\n/* harmony export */ });\nclass GLTFTexture {\n    constructor(sampler, image) {\n        this.sampler = sampler;\n        this.image = image;\n    }\n    setUsage(usage) {\n        this.image.setUsage(usage);\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/gltf/texture.ts?");

/***/ }),

/***/ "./src/view/renderer.ts":
/*!******************************!*\
  !*** ./src/view/renderer.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Renderer)\n/* harmony export */ });\n/* harmony import */ var wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wgpu-matrix */ \"./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js\");\n/* harmony import */ var _gltf_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf/loader */ \"./src/view/gltf/loader.ts\");\n/* harmony import */ var _shaders_color_frag_wgsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/color_frag.wgsl */ \"./src/view/shaders/color_frag.wgsl\");\n/* harmony import */ var _shaders_color_vert_wgsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/color_vert.wgsl */ \"./src/view/shaders/color_vert.wgsl\");\n/* harmony import */ var _shaders_color_vert_skinned_wgsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/color_vert_skinned.wgsl */ \"./src/view/shaders/color_vert_skinned.wgsl\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nclass Renderer {\n    constructor(canvas) {\n        this.identity = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.identity();\n        this.render = (renderables, modelNodeChunks, models) => {\n            const projView = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.mul(this.projection, renderables.viewTransform);\n            this.encoder = this.device.createCommandEncoder();\n            this.view = this.context.getCurrentTexture().createView();\n            this.set_joint_buffers(renderables.jointMatricesBufferList, models);\n            this.renderPass = this.encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: this.view,\n                        loadOp: 'clear',\n                        clearValue: [0.0, 0.0, 0.0, 1.0],\n                        storeOp: 'store',\n                    },\n                ],\n                depthStencilAttachment: this.depthStencilAttachment,\n            });\n            this.device.queue.writeBuffer(this.modelTransformsBuffer, 0, renderables.nodeTransforms);\n            this.device.queue.writeBuffer(this.normalTransformBuffer, 0, renderables.normalTransforms);\n            this.device.queue.writeBuffer(this.projViewTransformBuffer, 0, projView);\n            this.renderChunk('opaque', modelNodeChunks.opaque);\n            if (modelNodeChunks.transparent.length) {\n                this.renderChunk('transparent', modelNodeChunks.transparent);\n            }\n            this.renderPass.end();\n            this.device.queue.submit([this.encoder.finish()]);\n        };\n        this.canvas = canvas;\n        this.context = canvas.getContext('webgpu');\n        this.fov = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.utils.degToRad(60);\n        this.aspect = canvas.width / canvas.height;\n        this.projection = wgpu_matrix__WEBPACK_IMPORTED_MODULE_4__.mat4.perspective(this.fov, this.aspect, 0.01, 1000);\n    }\n    setupDevice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.adapter = (yield navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }));\n            this.device = (yield this.adapter.requestDevice());\n            this.format = navigator.gpu.getPreferredCanvasFormat();\n            this.colorVertShaderModule = (this.device.createShaderModule({ label: 'colorVertShaderModule', code: _shaders_color_vert_wgsl__WEBPACK_IMPORTED_MODULE_2__[\"default\"] }));\n            this.colorVertShaderModuleSkinned = (this.device.createShaderModule({ label: 'colorVertShaderModuleSkinned', code: _shaders_color_vert_skinned_wgsl__WEBPACK_IMPORTED_MODULE_3__[\"default\"] }));\n            this.colorFragShaderModule = (this.device.createShaderModule({ label: 'colorFragShaderModule', code: _shaders_color_frag_wgsl__WEBPACK_IMPORTED_MODULE_1__[\"default\"] }));\n            this.context.configure({\n                device: this.device,\n                format: this.format,\n                alphaMode: 'premultiplied',\n            });\n        });\n    }\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.createBuffers();\n            this.createDepthTexture();\n            this.createBindGroupLayouts();\n            this.createBindGroups();\n            this.createPipeline();\n        });\n    }\n    createBuffers() {\n        this.modelTransformsBuffer = this.device.createBuffer({\n            label: 'Model Transform Buffer',\n            size: 4 * 16 * _gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes.length,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.normalTransformBuffer = this.device.createBuffer({\n            label: 'Normal Transform Buffer',\n            size: 4 * 16 * _gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes.length,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n        this.projViewTransformBuffer = this.device.createBuffer({\n            label: 'Proj-View Transform Buffer',\n            size: 4 * 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n    }\n    createDepthTexture() {\n        this.depthFormat = 'depth24plus';\n        this.depthStencilState = {\n            format: this.depthFormat,\n            depthWriteEnabled: true,\n            depthCompare: 'less',\n        };\n        this.depthTexture = this.device.createTexture({\n            size: { width: this.canvas.width, height: this.canvas.height, depthOrArrayLayers: 1 },\n            format: this.depthFormat,\n            usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        this.depthStencilView = this.depthTexture.createView({\n            format: this.depthFormat,\n            dimension: '2d',\n            aspect: 'depth-only',\n        });\n        this.depthStencilAttachment = {\n            view: this.depthStencilView,\n            depthClearValue: 1.0,\n            depthLoadOp: 'clear',\n            depthStoreOp: 'store',\n        };\n    }\n    createBindGroupLayouts() {\n        this.frameBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    // Model matrices\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: 'read-only-storage',\n                        hasDynamicOffset: false,\n                    },\n                },\n                {\n                    // Normal matrices\n                    binding: 1,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: 'read-only-storage',\n                        hasDynamicOffset: false,\n                    },\n                },\n                {\n                    // Proj-View matrix\n                    binding: 2,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: 'read-only-storage',\n                        hasDynamicOffset: false,\n                    },\n                },\n            ],\n        });\n        this.materialBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    // Material Params\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: 'uniform',\n                    },\n                },\n                {\n                    // Base Color Sampler\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    // Base Color Texture\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {},\n                },\n                {\n                    // Metallic Roughness Sampler\n                    binding: 3,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {},\n                },\n                {\n                    // Metallic Roughness Texture\n                    binding: 4,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {},\n                },\n            ],\n        });\n        this.jointBindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    // Joint matrices\n                    binding: 0,\n                    visibility: GPUShaderStage.VERTEX,\n                    buffer: {\n                        type: 'read-only-storage',\n                    },\n                },\n            ],\n        });\n    }\n    createBindGroups() {\n        this.frameBindGroup = this.device.createBindGroup({\n            layout: this.frameBindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: this.modelTransformsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: this.normalTransformBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: this.projViewTransformBuffer,\n                    },\n                },\n            ],\n        });\n    }\n    createPipeline() {\n        const bindGroupLayouts = [this.frameBindGroupLayout, this.materialBindGroupLayout];\n        const bindGroupLayoutsSkinned = bindGroupLayouts.concat(this.jointBindGroupLayout);\n        const vertexBuffers = [\n            {\n                arrayStride: 12,\n                attributes: [\n                    {\n                        // position\n                        shaderLocation: 0,\n                        format: 'float32x3',\n                        offset: 0,\n                    },\n                ],\n            },\n            {\n                arrayStride: 12,\n                attributes: [\n                    {\n                        // normal\n                        shaderLocation: 1,\n                        format: 'float32x3',\n                        offset: 0,\n                    },\n                ],\n            },\n            {\n                arrayStride: 8,\n                attributes: [\n                    {\n                        // text coord\n                        shaderLocation: 2,\n                        format: 'float32x2',\n                        offset: 0,\n                    },\n                ],\n            },\n        ];\n        const vertexBuffersSkinned = vertexBuffers.concat({\n            arrayStride: 4,\n            attributes: [\n                {\n                    // joint\n                    shaderLocation: 3,\n                    format: 'uint8x4',\n                    offset: 0,\n                },\n            ],\n        }, {\n            arrayStride: 16,\n            attributes: [\n                {\n                    // weight\n                    shaderLocation: 4,\n                    format: 'float32x4',\n                    offset: 0,\n                },\n            ],\n        });\n        const targets = [\n            {\n                format: this.format,\n                blend: {\n                    color: {\n                        srcFactor: 'one',\n                        dstFactor: 'one-minus-src-alpha',\n                    },\n                    alpha: {\n                        srcFactor: 'one',\n                        dstFactor: 'one-minus-src-alpha',\n                    },\n                },\n            },\n        ];\n        this.pipelineOpaque = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: bindGroupLayouts,\n            }),\n            vertex: {\n                module: this.colorVertShaderModule,\n                entryPoint: 'v_main',\n                buffers: vertexBuffers,\n            },\n            fragment: {\n                module: this.colorFragShaderModule,\n                entryPoint: 'f_main',\n                targets: targets,\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            depthStencil: this.depthStencilState,\n        });\n        this.pipelineOpaqueSkinned = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: bindGroupLayoutsSkinned,\n            }),\n            vertex: {\n                module: this.colorVertShaderModuleSkinned,\n                entryPoint: 'v_main',\n                buffers: vertexBuffersSkinned,\n            },\n            fragment: {\n                module: this.colorFragShaderModule,\n                entryPoint: 'f_main',\n                targets: targets,\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            depthStencil: this.depthStencilState,\n        });\n        this.pipelineTransparent = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: bindGroupLayouts,\n            }),\n            vertex: {\n                module: this.colorVertShaderModule,\n                entryPoint: 'v_main',\n                buffers: vertexBuffers,\n            },\n            fragment: {\n                module: this.colorFragShaderModule,\n                entryPoint: 'f_main',\n                targets: targets,\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            depthStencil: {\n                format: this.depthFormat,\n                depthWriteEnabled: false,\n                depthCompare: 'less',\n            },\n        });\n        this.pipelineTransparentSkinned = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: bindGroupLayoutsSkinned,\n            }),\n            vertex: {\n                module: this.colorVertShaderModuleSkinned,\n                entryPoint: 'v_main',\n                buffers: vertexBuffersSkinned,\n            },\n            fragment: {\n                module: this.colorFragShaderModule,\n                entryPoint: 'f_main',\n                targets: targets,\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            depthStencil: {\n                format: this.depthFormat,\n                depthWriteEnabled: false,\n                depthCompare: 'less',\n            },\n        });\n    }\n    set_joint_buffers(jointMatricesBufferList, models) {\n        for (let i = 0; i < models.length; i++) {\n            const node = _gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[models[i].nodeIndex];\n            if (!node.skin)\n                continue;\n            this.encoder.copyBufferToBuffer(jointMatricesBufferList[i], 0, node.skin.jointMatricesBuffer, 0, node.skin.jointMatricesBuffer.size);\n        }\n    }\n    renderChunk(chunkType, chunk) {\n        for (let i = 0; i < chunk.length; i++) {\n            const nodeIndex = chunk[i].nodeIndex;\n            const primIndex = chunk[i].primitiveIndex;\n            const node = _gltf_loader__WEBPACK_IMPORTED_MODULE_0__.nodes[nodeIndex];\n            if (!node.mesh)\n                continue;\n            const p = node.mesh.primitives[primIndex];\n            if (node.skin) {\n                if (chunkType === 'transparent') {\n                    this.renderPass.setPipeline(this.pipelineTransparentSkinned);\n                }\n                else {\n                    this.renderPass.setPipeline(this.pipelineOpaqueSkinned);\n                }\n                this.renderPass.setBindGroup(2, node.skin.jointBindGroup);\n                this.renderPass.setVertexBuffer(3, p.joints.bufferView.gpuBuffer, p.joints.byteOffset, p.joints.byteLength);\n                this.renderPass.setVertexBuffer(4, p.weights.bufferView.gpuBuffer, p.weights.byteOffset, p.weights.byteLength);\n            }\n            else {\n                if (chunkType === 'transparent') {\n                    this.renderPass.setPipeline(this.pipelineTransparent);\n                }\n                else {\n                    this.renderPass.setPipeline(this.pipelineOpaque);\n                }\n            }\n            this.renderPass.setBindGroup(0, this.frameBindGroup);\n            this.renderPass.setBindGroup(1, p.material.bindGroup);\n            this.renderPass.setVertexBuffer(0, p.positions.bufferView.gpuBuffer, p.positions.byteOffset, p.positions.byteLength);\n            this.renderPass.setVertexBuffer(1, p.normals.bufferView.gpuBuffer, p.normals.byteOffset, p.normals.byteLength);\n            this.renderPass.setVertexBuffer(2, p.texCoords.bufferView.gpuBuffer, p.texCoords.byteOffset, p.texCoords.byteLength);\n            if (p.indices) {\n                this.renderPass.setIndexBuffer(p.indices.bufferView.gpuBuffer, p.indices.elementType, p.indices.byteOffset, p.indices.byteLength);\n                this.renderPass.drawIndexed(p.indices.count, 1, 0, 0, nodeIndex);\n            }\n            else {\n                this.renderPass.draw(p.positions.count, 1, 0, nodeIndex);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://game_engine/./src/view/renderer.ts?");

/***/ }),

/***/ "./src/view/compute/joint_matrices/joint_matrices.wgsl":
/*!*************************************************************!*\
  !*** ./src/view/compute/joint_matrices/joint_matrices.wgsl ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"@group(0) @binding(0) var<storage, read> inverseBindMatrices : array<mat4x4f>;\\r\\n@group(0) @binding(1) var<storage, read> inverseGlobalTransform : mat4x4f;\\r\\n@group(0) @binding(2) var<storage, read> globalJointTransforms : array<mat4x4f>;\\r\\n@group(0) @binding(3) var<storage, read_write> jointMatrices : array<mat4x4f>;\\r\\n\\r\\n@compute @workgroup_size(1, 1, 1)\\r\\nfn main(@builtin(global_invocation_id) global_id: vec3u) {\\r\\n    for (var i: u32 = 0; i < arrayLength(&inverseBindMatrices); i++) {\\r\\n        jointMatrices[i] = globalJointTransforms[i] * inverseBindMatrices[i];\\r\\n        // jointMatrices[i] = mat4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\\r\\n    }\\r\\n}\");\n\n//# sourceURL=webpack://game_engine/./src/view/compute/joint_matrices/joint_matrices.wgsl?");

/***/ }),

/***/ "./src/view/shaders/color_frag.wgsl":
/*!******************************************!*\
  !*** ./src/view/shaders/color_frag.wgsl ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct VertexOutput {\\r\\n    @builtin(position) position: vec4f,\\r\\n    @location(1) world_pos: vec3f,\\r\\n    @location(2) normal: vec3f,\\r\\n    @location(3) texcoords: vec2f,\\r\\n};\\r\\n\\r\\nstruct MaterialParams {\\r\\n    base_color_factor: vec4f,\\r\\n    metallic_factor: f32,\\r\\n    roughness_factor: f32,\\r\\n};\\r\\n\\r\\n@group(1) @binding(0) var<uniform> material_params: MaterialParams;\\r\\n@group(1) @binding(1) var base_color_sampler: sampler;\\r\\n@group(1) @binding(2) var base_color_texture: texture_2d<f32>;\\r\\n@group(1) @binding(3) var metallic_roughness_sampler: sampler;\\r\\n@group(1) @binding(4) var metallic_roughness_texture: texture_2d<f32>;\\r\\n\\r\\nfn linear_to_srgb(x: f32) -> f32 {\\r\\n    if (x <= 0.0031308) {\\r\\n        return 12.92 * x;\\r\\n    }\\r\\n    return 1.055 * pow(x, 1.0 / 2.4) - 0.055;\\r\\n}\\r\\n\\r\\n@fragment\\r\\nfn f_main(in: VertexOutput) -> @location(0) vec4f {\\r\\n    let colorTextureDimensions: vec2u = textureDimensions(base_color_texture);\\r\\n    let hasColorTexture: bool = colorTextureDimensions.x > 1;\\r\\n\\r\\n    let metallicRoughnessTextureDimensions: vec2u = textureDimensions(metallic_roughness_texture);\\r\\n    let hasMetallicRoughnessTexture: bool = metallicRoughnessTextureDimensions.x > 1;\\r\\n\\r\\n    let base_color = textureSample(base_color_texture, base_color_sampler, in.texcoords);\\r\\n    let metallic_roughness = textureSample(metallic_roughness_texture, metallic_roughness_sampler, in.texcoords);\\r\\n\\r\\n    var color = vec4f(1.0, 1.0, 1.0, 1.0);\\r\\n    if (hasColorTexture) {\\r\\n        color = material_params.base_color_factor * base_color;\\r\\n        color.r = linear_to_srgb(color.r);\\r\\n        color.g = linear_to_srgb(color.g);\\r\\n        color.b = linear_to_srgb(color.b);\\r\\n        color.a = color.a;\\r\\n    } else {\\r\\n        color.r = linear_to_srgb(material_params.base_color_factor.r);\\r\\n        color.g = linear_to_srgb(material_params.base_color_factor.g);\\r\\n        color.b = linear_to_srgb(material_params.base_color_factor.b);\\r\\n        color.a = material_params.base_color_factor.a;\\r\\n\\r\\n        // color = vec4f((in.normal + 1.0) * 0.5, 1.0); // Remove later\\r\\n        // color.r = linear_to_srgb(color.r);\\r\\n        // color.g = linear_to_srgb(color.g);\\r\\n        // color.b = linear_to_srgb(color.b);\\r\\n        // color.a = 1.0;\\r\\n    }\\r\\n    return color;\\r\\n}\");\n\n//# sourceURL=webpack://game_engine/./src/view/shaders/color_frag.wgsl?");

/***/ }),

/***/ "./src/view/shaders/color_vert.wgsl":
/*!******************************************!*\
  !*** ./src/view/shaders/color_vert.wgsl ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct VertexInput {\\r\\n    @builtin(instance_index) i_id: u32,\\r\\n    @location(0) position: vec3f,\\r\\n    @location(1) normal: vec3f,\\r\\n    @location(2) texcoords: vec2f,\\r\\n};\\r\\n\\r\\nstruct VertexOutput {\\r\\n    @builtin(position) position: vec4f,\\r\\n    @location(1) world_pos: vec3f,\\r\\n    @location(2) normal: vec3f,\\r\\n    @location(3) texcoords: vec2f,\\r\\n};\\r\\n\\r\\n@group(0) @binding(0) var<storage, read> model_transforms: array<mat4x4f>;\\r\\n@group(0) @binding(1) var<storage, read> normal_transforms: array<mat4x4f>;\\r\\n@group(0) @binding(2) var<storage, read> proj_view_transform: mat4x4f;\\r\\n\\r\\nfn extractMat3FromMat4(m: mat4x4f) -> mat3x3f {\\r\\n    return mat3x3(\\r\\n        m[0].xyz,\\r\\n        m[1].xyz,\\r\\n        m[2].xyz\\r\\n    );\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn v_main(vert: VertexInput) -> VertexOutput {\\r\\n    var out: VertexOutput;\\r\\n\\r\\n    out.position = proj_view_transform * model_transforms[vert.i_id] * vec4f(vert.position, 1.0);\\r\\n    out.world_pos = vert.position.xyz;\\r\\n    out.normal = extractMat3FromMat4(normal_transforms[vert.i_id]) * vert.normal;\\r\\n    out.texcoords = vert.texcoords;\\r\\n    return out;\\r\\n}\");\n\n//# sourceURL=webpack://game_engine/./src/view/shaders/color_vert.wgsl?");

/***/ }),

/***/ "./src/view/shaders/color_vert_skinned.wgsl":
/*!**************************************************!*\
  !*** ./src/view/shaders/color_vert_skinned.wgsl ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct VertexInput {\\r\\n    @builtin(instance_index) i_id: u32,\\r\\n    @location(0) position: vec3f,\\r\\n    @location(1) normal: vec3f,\\r\\n    @location(2) texcoords: vec2f,\\r\\n    @location(3) joint: vec4u,\\r\\n    @location(4) weight: vec4f,\\r\\n};\\r\\n\\r\\nstruct VertexOutput {\\r\\n    @builtin(position) position: vec4f,\\r\\n    @location(1) world_pos: vec3f,\\r\\n    @location(2) normal: vec3f,\\r\\n    @location(3) texcoords: vec2f,\\r\\n};\\r\\n\\r\\n@group(0) @binding(0) var<storage, read> model_transforms: array<mat4x4f>;\\r\\n@group(0) @binding(1) var<storage, read> normal_transforms: array<mat4x4f>;\\r\\n@group(0) @binding(2) var<storage, read> proj_view_transform: mat4x4f;\\r\\n\\r\\n@group(2) @binding(0) var<storage, read> jointMatrices: array<mat4x4f>;\\r\\n\\r\\nfn extractMat3FromMat4(m: mat4x4f) -> mat3x3f {\\r\\n    return mat3x3(\\r\\n        m[0].xyz,\\r\\n        m[1].xyz,\\r\\n        m[2].xyz\\r\\n    );\\r\\n}\\r\\n\\r\\nfn get_skin_matrix(weight: vec4f, joint: vec4u) -> mat4x4f {\\r\\n    return mat4x4f(weight.x * jointMatrices[joint.x] + \\r\\n    weight.y * jointMatrices[joint.y] + \\r\\n    weight.z * jointMatrices[joint.z] + \\r\\n    weight.w * jointMatrices[joint.w]);\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn v_main(vert: VertexInput) -> VertexOutput {\\r\\n    var out: VertexOutput;\\r\\n\\r\\n    let skinMatrix: mat4x4f = get_skin_matrix(vert.weight, vert.joint);\\r\\n\\r\\n    out.position = proj_view_transform * model_transforms[vert.i_id] * skinMatrix * vec4f(vert.position, 1.0);\\r\\n    out.world_pos = vert.position.xyz;\\r\\n    out.normal = extractMat3FromMat4(normal_transforms[vert.i_id]) * vert.normal;\\r\\n    out.texcoords = vert.texcoords;\\r\\n    return out;\\r\\n}\");\n\n//# sourceURL=webpack://game_engine/./src/view/shaders/color_vert_skinned.wgsl?");

/***/ }),

/***/ "./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js":
/*!*****************************************************************!*\
  !*** ./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mat3: () => (/* binding */ mat3),\n/* harmony export */   mat3d: () => (/* binding */ mat3d),\n/* harmony export */   mat3n: () => (/* binding */ mat3n),\n/* harmony export */   mat4: () => (/* binding */ mat4),\n/* harmony export */   mat4d: () => (/* binding */ mat4d),\n/* harmony export */   mat4n: () => (/* binding */ mat4n),\n/* harmony export */   quat: () => (/* binding */ quat),\n/* harmony export */   quatd: () => (/* binding */ quatd),\n/* harmony export */   quatn: () => (/* binding */ quatn),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   vec2: () => (/* binding */ vec2),\n/* harmony export */   vec2d: () => (/* binding */ vec2d),\n/* harmony export */   vec2n: () => (/* binding */ vec2n),\n/* harmony export */   vec3: () => (/* binding */ vec3),\n/* harmony export */   vec3d: () => (/* binding */ vec3d),\n/* harmony export */   vec3n: () => (/* binding */ vec3n),\n/* harmony export */   vec4: () => (/* binding */ vec4),\n/* harmony export */   vec4d: () => (/* binding */ vec4d),\n/* harmony export */   vec4n: () => (/* binding */ vec4n)\n/* harmony export */ });\n/* wgpu-matrix@3.0.1, license MIT */\nfunction wrapConstructor(OriginalConstructor, modifier) {\n    return class extends OriginalConstructor {\n        constructor(...args) {\n            super(...args);\n            modifier(this);\n        }\n    }; // Type assertion is necessary here\n}\nconst ZeroArray = wrapConstructor((Array), a => a.fill(0));\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = {\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n};\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Vec3\n */\nfunction getAPIImpl$5(Ctor) {\n    /**\n     * Creates a Vec2; may be called with x, y, z to set initial values.\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Vec2's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const v = vec2.clone(someJSArray);\n     * ```\n     *\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @returns the created vector\n     */\n    function create(x = 0, y = 0) {\n        const newDst = new Ctor(2);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Vec2\n     * Also see {@link vec2.create} and {@link vec2.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = x;\n        newDst[1] = y;\n        return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.ceil(v[0]);\n        newDst[1] = Math.ceil(v[1]);\n        return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.floor(v[0]);\n        newDst[1] = Math.floor(v[1]);\n        return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.round(v[0]);\n        newDst[1] = Math.round(v[1]);\n        return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v, min = 0, max = 1, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.min(max, Math.max(min, v[0]));\n        newDst[1] = Math.min(max, Math.max(min, v[1]));\n        return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + b[0] * scale;\n        newDst[1] = a[1] + b[1] * scale;\n        return newDst;\n    }\n    /**\n     * Returns the angle in radians between two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns The angle in radians between the 2 vectors.\n     */\n    function angle(a, b) {\n        const ax = a[0];\n        const ay = a[1];\n        const bx = b[0];\n        const by = b[1];\n        const mag1 = Math.sqrt(ax * ax + ay * ay);\n        const mag2 = Math.sqrt(bx * bx + by * by);\n        const mag = mag1 * mag2;\n        const cosine = mag && dot(a, b) / mag;\n        return Math.acos(cosine);\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n        newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n        return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.max(a[0], b[0]);\n        newDst[1] = Math.max(a[1], b[1]);\n        return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = Math.min(a[0], b[0]);\n        newDst[1] = Math.min(a[1], b[1]);\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = 1 / v[0];\n        newDst[1] = 1 / v[1];\n        return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    const invert = inverse;\n    /**\n     * Computes the cross product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of a cross b.\n     */\n    function cross(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const z = a[0] * b[1] - a[1] * b[0];\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = z;\n        return newDst;\n    }\n    /**\n     * Computes the dot product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1];\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        return Math.sqrt(v0 * v0 + v1 * v1);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        return v0 * v0 + v1 * v1;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    const dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        return dx * dx + dy * dy;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    const distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const v0 = v[0];\n        const v1 = v[1];\n        const len = Math.sqrt(v0 * v0 + v1 * v1);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = -v[0];\n        newDst[1] = -v[1];\n        return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec2.clone})\n     * Also see {@link vec2.create} and {@link vec2.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = v[0];\n        newDst[1] = v[1];\n        return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec2.copy})\n     * Also see {@link vec2.create} and {@link vec2.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    const clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] * b[0];\n        newDst[1] = a[1] * b[1];\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = a[0] / b[0];\n        newDst[1] = a[1] / b[1];\n        return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    const div = divide;\n    /**\n     * Creates a random unit vector * scale\n     * @param scale - Default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The random vector.\n     */\n    function random(scale = 1, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const angle = Math.random() * 2 * Math.PI;\n        newDst[0] = Math.cos(angle) * scale;\n        newDst[1] = Math.sin(angle) * scale;\n        return newDst;\n    }\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n        const newDst = (dst ?? new Ctor(2));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        return newDst;\n    }\n    /**\n     * transform Vec2 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional Vec2 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const x = v[0];\n        const y = v[1];\n        newDst[0] = x * m[0] + y * m[4] + m[12];\n        newDst[1] = x * m[1] + y * m[5] + m[13];\n        return newDst;\n    }\n    /**\n     * Transforms vec4 by 3x3 matrix\n     *\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional Vec2 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat3(v, m, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        const x = v[0];\n        const y = v[1];\n        newDst[0] = m[0] * x + m[4] * y + m[8];\n        newDst[1] = m[1] * x + m[5] * y + m[9];\n        return newDst;\n    }\n    /**\n     * Rotate a 2D vector\n     *\n     * @param a The vec2 point to rotate\n     * @param b The origin of the rotation\n     * @param rad The angle of rotation in radians\n     * @returns the rotated vector\n     */\n    function rotate(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        // Translate point to the origin\n        const p0 = a[0] - b[0];\n        const p1 = a[1] - b[1];\n        const sinC = Math.sin(rad);\n        const cosC = Math.cos(rad);\n        //perform rotation and translate to correct position\n        newDst[0] = p0 * cosC - p1 * sinC + b[0];\n        newDst[1] = p0 * sinC + p1 * cosC + b[1];\n        return newDst;\n    }\n    /**\n     * Treat a 2D vector as a direction and set it's length\n     *\n     * @param a The vec2 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        normalize(a, newDst);\n        return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec2 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        if (length(a) > maxLen) {\n            return setLength(a, maxLen, newDst);\n        }\n        return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n        const newDst = (dst ?? new Ctor(2));\n        return lerp(a, b, 0.5, newDst);\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        ceil,\n        floor,\n        round,\n        clamp,\n        add,\n        addScaled,\n        angle,\n        subtract,\n        sub,\n        equalsApproximately,\n        equals,\n        lerp,\n        lerpV,\n        max,\n        min,\n        mulScalar,\n        scale,\n        divScalar,\n        inverse,\n        invert,\n        cross,\n        dot,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        distance,\n        dist,\n        distanceSq,\n        distSq,\n        normalize,\n        negate,\n        copy,\n        clone,\n        multiply,\n        mul,\n        divide,\n        div,\n        random,\n        zero,\n        transformMat4,\n        transformMat3,\n        rotate,\n        setLength,\n        truncate,\n        midpoint,\n    };\n}\nconst cache$5 = new Map();\nfunction getAPI$5(Ctor) {\n    let api = cache$5.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$5(Ctor);\n        cache$5.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates a typed API for Mat3\n * */\nfunction getAPIImpl$4(Ctor) {\n    const vec2 = getAPI$5(Ctor);\n    /**\n     * Create a Mat3 from values\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Mat3's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const m = mat3.clone(someJSArray);\n     * ```\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @returns matrix created from values.\n     */\n    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n        const newDst = new Ctor(12);\n        // to make the array homogenous\n        newDst[3] = 0;\n        newDst[7] = 0;\n        newDst[11] = 0;\n        if (v0 !== undefined) {\n            newDst[0] = v0;\n            if (v1 !== undefined) {\n                newDst[1] = v1;\n                if (v2 !== undefined) {\n                    newDst[2] = v2;\n                    if (v3 !== undefined) {\n                        newDst[4] = v3;\n                        if (v4 !== undefined) {\n                            newDst[5] = v4;\n                            if (v5 !== undefined) {\n                                newDst[6] = v5;\n                                if (v6 !== undefined) {\n                                    newDst[8] = v6;\n                                    if (v7 !== undefined) {\n                                        newDst[9] = v7;\n                                        if (v8 !== undefined) {\n                                            newDst[10] = v8;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Sets the values of a Mat3\n     * Also see {@link mat3.create} and {@link mat3.copy}\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 set from values.\n     */\n    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = v0;\n        newDst[1] = v1;\n        newDst[2] = v2;\n        newDst[3] = 0;\n        newDst[4] = v3;\n        newDst[5] = v4;\n        newDst[6] = v5;\n        newDst[7] = 0;\n        newDst[8] = v6;\n        newDst[9] = v7;\n        newDst[10] = v8;\n        newDst[11] = 0;\n        return newDst;\n    }\n    /**\n     * Creates a Mat3 from the upper left 3x3 part of a Mat4\n     * @param m4 - source matrix\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 made from m4\n     */\n    function fromMat4(m4, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = m4[0];\n        newDst[1] = m4[1];\n        newDst[2] = m4[2];\n        newDst[3] = 0;\n        newDst[4] = m4[4];\n        newDst[5] = m4[5];\n        newDst[6] = m4[6];\n        newDst[7] = 0;\n        newDst[8] = m4[8];\n        newDst[9] = m4[9];\n        newDst[10] = m4[10];\n        newDst[11] = 0;\n        return newDst;\n    }\n    /**\n     * Creates a Mat3 rotation matrix from a quaternion\n     * @param q - quaternion to create matrix from\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat3 made from q\n     */\n    function fromQuat(q, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const yx = y * x2;\n        const yy = y * y2;\n        const zx = z * x2;\n        const zy = z * y2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        newDst[0] = 1 - yy - zz;\n        newDst[1] = yx + wz;\n        newDst[2] = zx - wy;\n        newDst[3] = 0;\n        newDst[4] = yx - wz;\n        newDst[5] = 1 - xx - zz;\n        newDst[6] = zy + wx;\n        newDst[7] = 0;\n        newDst[8] = zx + wy;\n        newDst[9] = zy - wx;\n        newDst[10] = 1 - xx - yy;\n        newDst[11] = 0;\n        return newDst;\n    }\n    /**\n     * Negates a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns -m.\n     */\n    function negate(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = -m[0];\n        newDst[1] = -m[1];\n        newDst[2] = -m[2];\n        newDst[4] = -m[4];\n        newDst[5] = -m[5];\n        newDst[6] = -m[6];\n        newDst[8] = -m[8];\n        newDst[9] = -m[9];\n        newDst[10] = -m[10];\n        return newDst;\n    }\n    /**\n     * Copies a matrix. (same as {@link mat3.clone})\n     * Also see {@link mat3.create} and {@link mat3.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    function copy(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = m[0];\n        newDst[1] = m[1];\n        newDst[2] = m[2];\n        newDst[4] = m[4];\n        newDst[5] = m[5];\n        newDst[6] = m[6];\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n        return newDst;\n    }\n    /**\n     * Copies a matrix (same as {@link mat3.copy})\n     * Also see {@link mat3.create} and {@link mat3.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    const clone = copy;\n    /**\n     * Check if 2 matrices are approximately equal\n     * @param a Operand matrix.\n     * @param b Operand matrix.\n     * @returns true if matrices are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[4] - b[4]) < EPSILON &&\n            Math.abs(a[5] - b[5]) < EPSILON &&\n            Math.abs(a[6] - b[6]) < EPSILON &&\n            Math.abs(a[8] - b[8]) < EPSILON &&\n            Math.abs(a[9] - b[9]) < EPSILON &&\n            Math.abs(a[10] - b[10]) < EPSILON;\n    }\n    /**\n     * Check if 2 matrices are exactly equal\n     * @param a Operand matrix.\n     * @param b Operand matrix.\n     * @returns true if matrices are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] &&\n            a[1] === b[1] &&\n            a[2] === b[2] &&\n            a[4] === b[4] &&\n            a[5] === b[5] &&\n            a[6] === b[6] &&\n            a[8] === b[8] &&\n            a[9] === b[9] &&\n            a[10] === b[10];\n    }\n    /**\n     * Creates a 3-by-3 identity matrix.\n     *\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A 3-by-3 identity matrix.\n     */\n    function identity(dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Takes the transpose of a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The transpose of m.\n     */\n    function transpose(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        if (newDst === m) {\n            let t;\n            // 0 1 2\n            // 4 5 6\n            // 8 9 10\n            t = m[1];\n            m[1] = m[4];\n            m[4] = t;\n            t = m[2];\n            m[2] = m[8];\n            m[8] = t;\n            t = m[6];\n            m[6] = m[9];\n            m[9] = t;\n            return newDst;\n        }\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        newDst[0] = m00;\n        newDst[1] = m10;\n        newDst[2] = m20;\n        newDst[4] = m01;\n        newDst[5] = m11;\n        newDst[6] = m21;\n        newDst[8] = m02;\n        newDst[9] = m12;\n        newDst[10] = m22;\n        return newDst;\n    }\n    /**\n     * Computes the inverse of a 3-by-3 matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    function inverse(m, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const b01 = m22 * m11 - m12 * m21;\n        const b11 = -m22 * m10 + m12 * m20;\n        const b21 = m21 * m10 - m11 * m20;\n        const invDet = 1 / (m00 * b01 + m01 * b11 + m02 * b21);\n        newDst[0] = b01 * invDet;\n        newDst[1] = (-m22 * m01 + m02 * m21) * invDet;\n        newDst[2] = (m12 * m01 - m02 * m11) * invDet;\n        newDst[4] = b11 * invDet;\n        newDst[5] = (m22 * m00 - m02 * m20) * invDet;\n        newDst[6] = (-m12 * m00 + m02 * m10) * invDet;\n        newDst[8] = b21 * invDet;\n        newDst[9] = (-m21 * m00 + m01 * m20) * invDet;\n        newDst[10] = (m11 * m00 - m01 * m10) * invDet;\n        return newDst;\n    }\n    /**\n     * Compute the determinant of a matrix\n     * @param m - the matrix\n     * @returns the determinant\n     */\n    function determinant(m) {\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        return m00 * (m11 * m22 - m21 * m12) -\n            m10 * (m01 * m22 - m21 * m02) +\n            m20 * (m01 * m12 - m11 * m02);\n    }\n    /**\n     * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    const invert = inverse;\n    /**\n     * Multiplies two 3-by-3 matrices with a on the left and b on the right\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a10 = a[4 + 0];\n        const a11 = a[4 + 1];\n        const a12 = a[4 + 2];\n        const a20 = a[8 + 0];\n        const a21 = a[8 + 1];\n        const a22 = a[8 + 2];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b10 = b[4 + 0];\n        const b11 = b[4 + 1];\n        const b12 = b[4 + 2];\n        const b20 = b[8 + 0];\n        const b21 = b[8 + 1];\n        const b22 = b[8 + 2];\n        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n        return newDst;\n    }\n    /**\n     * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Sets the translation component of a 3-by-3 matrix to the given\n     * vector.\n     * @param a - The matrix.\n     * @param v - The vector.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix with translation set.\n     */\n    function setTranslation(a, v, dst) {\n        const newDst = (dst ?? identity());\n        if (a !== newDst) {\n            newDst[0] = a[0];\n            newDst[1] = a[1];\n            newDst[2] = a[2];\n            newDst[4] = a[4];\n            newDst[5] = a[5];\n            newDst[6] = a[6];\n        }\n        newDst[8] = v[0];\n        newDst[9] = v[1];\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Returns the translation component of a 3-by-3 matrix as a vector with 3\n     * entries.\n     * @param m - The matrix.\n     * @param dst - vector to hold result. If not passed a new one is created.\n     * @returns The translation component of m.\n     */\n    function getTranslation(m, dst) {\n        const newDst = (dst ?? vec2.create());\n        newDst[0] = m[8];\n        newDst[1] = m[9];\n        return newDst;\n    }\n    /**\n     * Returns an axis of a 3x3 matrix as a vector with 2 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y,\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n        const newDst = (dst ?? vec2.create());\n        const off = axis * 4;\n        newDst[0] = m[off + 0];\n        newDst[1] = m[off + 1];\n        return newDst;\n    }\n    /**\n     * Sets an axis of a 3x3 matrix as a vector with 2 entries\n     * @param m - The matrix.\n     * @param v - the axis vector\n     * @param axis - The axis  0 = x, 1 = y;\n     * @param dst - The matrix to set. If not passed a new one is created.\n     * @returns The matrix with axis set.\n     */\n    function setAxis(m, v, axis, dst) {\n        const newDst = (dst === m ? m : copy(m, dst));\n        const off = axis * 4;\n        newDst[off + 0] = v[0];\n        newDst[off + 1] = v[1];\n        return newDst;\n    }\n    ///**\n    // * Returns the scaling component of the matrix\n    // * @param m - The Matrix\n    // * @param dst - The vector to set. If not passed a new one is created.\n    // */\n    function getScaling(m, dst) {\n        const newDst = (dst ?? vec2.create());\n        const xx = m[0];\n        const xy = m[1];\n        const yx = m[4];\n        const yy = m[5];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy);\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which translates by the given vector v.\n     * @param v - The vector by which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translation matrix.\n     */\n    function translation(v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[8] = v[0];\n        newDst[9] = v[1];\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Translates the given 3-by-3 matrix by the given vector v.\n     * @param m - The matrix.\n     * @param v - The vector by which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translated matrix.\n     */\n    function translate(m, v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const v0 = v[0];\n        const v1 = v[1];\n        const m00 = m[0];\n        const m01 = m[1];\n        const m02 = m[2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        if (m !== newDst) {\n            newDst[0] = m00;\n            newDst[1] = m01;\n            newDst[2] = m02;\n            newDst[4] = m10;\n            newDst[5] = m11;\n            newDst[6] = m12;\n        }\n        newDst[8] = m00 * v0 + m10 * v1 + m20;\n        newDst[9] = m01 * v0 + m11 * v1 + m21;\n        newDst[10] = m02 * v0 + m12 * v1 + m22;\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which rotates  by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotation(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = s;\n        newDst[2] = 0;\n        newDst[4] = -s;\n        newDst[5] = c;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 3-by-3 matrix  by the given angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotate(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 + s * m10;\n        newDst[1] = c * m01 + s * m11;\n        newDst[2] = c * m02 + s * m12;\n        newDst[4] = c * m10 - s * m00;\n        newDst[5] = c * m11 - s * m01;\n        newDst[6] = c * m12 - s * m02;\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has three\n     * entries.\n     * @param v - A vector of\n     *     2 entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling(v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = v[0];\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = v[1];\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * three entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of 2 entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale(m, v, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        const v0 = v[0];\n        const v1 = v[1];\n        newDst[0] = v0 * m[0 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2];\n        newDst[4] = v1 * m[1 * 4 + 0];\n        newDst[5] = v1 * m[1 * 4 + 1];\n        newDst[6] = v1 * m[1 * 4 + 2];\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 3-by-3 matrix which scales uniformly in each dimension\n     * @param s - Amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling(s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = s;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[4] = 0;\n        newDst[5] = s;\n        newDst[6] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 3-by-3 matrix in each dimension by an amount\n     * given.\n     * @param m - The matrix to be modified.\n     * @param s - Amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale(m, s, dst) {\n        const newDst = (dst ?? new Ctor(12));\n        newDst[0] = s * m[0 * 4 + 0];\n        newDst[1] = s * m[0 * 4 + 1];\n        newDst[2] = s * m[0 * 4 + 2];\n        newDst[4] = s * m[1 * 4 + 0];\n        newDst[5] = s * m[1 * 4 + 1];\n        newDst[6] = s * m[1 * 4 + 2];\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n        }\n        return newDst;\n    }\n    return {\n        clone,\n        create,\n        set,\n        fromMat4,\n        fromQuat,\n        negate,\n        copy,\n        equalsApproximately,\n        equals,\n        identity,\n        transpose,\n        inverse,\n        invert,\n        determinant,\n        mul,\n        multiply,\n        setTranslation,\n        getTranslation,\n        getAxis,\n        setAxis,\n        getScaling,\n        translation,\n        translate,\n        rotation,\n        rotate,\n        scaling,\n        scale,\n        uniformScaling,\n        uniformScale,\n    };\n}\nconst cache$4 = new Map();\nfunction getAPI$4(Ctor) {\n    let api = cache$4.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$4(Ctor);\n        cache$4.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Vec3\n * */\nfunction getAPIImpl$3(Ctor) {\n    /**\n     * Creates a vec3; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @returns the created vector\n     */\n    function create(x, y, z) {\n        const newDst = new Ctor(3);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n                if (z !== undefined) {\n                    newDst[2] = z;\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Vec3\n     * Also see {@link vec3.create} and {@link vec3.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = x;\n        newDst[1] = y;\n        newDst[2] = z;\n        return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.ceil(v[0]);\n        newDst[1] = Math.ceil(v[1]);\n        newDst[2] = Math.ceil(v[2]);\n        return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.floor(v[0]);\n        newDst[1] = Math.floor(v[1]);\n        newDst[2] = Math.floor(v[2]);\n        return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.round(v[0]);\n        newDst[1] = Math.round(v[1]);\n        newDst[2] = Math.round(v[2]);\n        return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v, min = 0, max = 1, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.min(max, Math.max(min, v[0]));\n        newDst[1] = Math.min(max, Math.max(min, v[1]));\n        newDst[2] = Math.min(max, Math.max(min, v[2]));\n        return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + b[0] * scale;\n        newDst[1] = a[1] + b[1] * scale;\n        newDst[2] = a[2] + b[2] * scale;\n        return newDst;\n    }\n    /**\n     * Returns the angle in radians between two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns The angle in radians between the 2 vectors.\n     */\n    function angle(a, b) {\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const bx = b[0];\n        const by = b[1];\n        const bz = b[2];\n        const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n        const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n        const mag = mag1 * mag2;\n        const cosine = mag && dot(a, b) / mag;\n        return Math.acos(cosine);\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        newDst[2] = a[2] - b[2];\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        newDst[2] = a[2] + t * (b[2] - a[2]);\n        return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n        newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n        newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n        return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.max(a[0], b[0]);\n        newDst[1] = Math.max(a[1], b[1]);\n        newDst[2] = Math.max(a[2], b[2]);\n        return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = Math.min(a[0], b[0]);\n        newDst[1] = Math.min(a[1], b[1]);\n        newDst[2] = Math.min(a[2], b[2]);\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        newDst[2] = v[2] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        newDst[2] = v[2] / k;\n        return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = 1 / v[0];\n        newDst[1] = 1 / v[1];\n        newDst[2] = 1 / v[2];\n        return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    const invert = inverse;\n    /**\n     * Computes the cross product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of a cross b.\n     */\n    function cross(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const t1 = a[2] * b[0] - a[0] * b[2];\n        const t2 = a[0] * b[1] - a[1] * b[0];\n        newDst[0] = a[1] * b[2] - a[2] * b[1];\n        newDst[1] = t1;\n        newDst[2] = t2;\n        return newDst;\n    }\n    /**\n     * Computes the dot product of two vectors; assumes both vectors have\n     * three entries.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return v0 * v0 + v1 * v1 + v2 * v2;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    const dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        return dx * dx + dy * dy + dz * dz;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    const distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n            newDst[2] = v2 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = -v[0];\n        newDst[1] = -v[1];\n        newDst[2] = -v[2];\n        return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec3.clone})\n     * Also see {@link vec3.create} and {@link vec3.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = v[0];\n        newDst[1] = v[1];\n        newDst[2] = v[2];\n        return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec3.copy})\n     * Also see {@link vec3.create} and {@link vec3.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    const clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] * b[0];\n        newDst[1] = a[1] * b[1];\n        newDst[2] = a[2] * b[2];\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = a[0] / b[0];\n        newDst[1] = a[1] / b[1];\n        newDst[2] = a[2] / b[2];\n        return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    const div = divide;\n    /**\n     * Creates a random vector\n     * @param scale - Default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The random vector.\n     */\n    function random(scale = 1, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const angle = Math.random() * 2 * Math.PI;\n        const z = Math.random() * 2 - 1;\n        const zScale = Math.sqrt(1 - z * z) * scale;\n        newDst[0] = Math.cos(angle) * zScale;\n        newDst[1] = Math.sin(angle) * zScale;\n        newDst[2] = z * scale;\n        return newDst;\n    }\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        return newDst;\n    }\n    /**\n     * transform vec3 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n        newDst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n        newDst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n        newDst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n        return newDst;\n    }\n    /**\n     * Transform vec3 by upper 3x3 matrix inside 4x4 matrix.\n     * @param v - The direction.\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns The transformed vector.\n     */\n    function transformMat4Upper3x3(v, m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        newDst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n        return newDst;\n    }\n    /**\n     * Transforms vec3 by 3x3 matrix\n     *\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat3(v, m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        newDst[0] = x * m[0] + y * m[4] + z * m[8];\n        newDst[1] = x * m[1] + y * m[5] + z * m[9];\n        newDst[2] = x * m[2] + y * m[6] + z * m[10];\n        return newDst;\n    }\n    /**\n     * Transforms vec3 by Quaternion\n     * @param v - the vector to transform\n     * @param q - the quaternion to transform by\n     * @param dst - optional vec3 to store result. If not passed a new one is created.\n     * @returns the transformed\n     */\n    function transformQuat(v, q, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const w2 = q[3] * 2;\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        const uvX = qy * z - qz * y;\n        const uvY = qz * x - qx * z;\n        const uvZ = qx * y - qy * x;\n        newDst[0] = x + uvX * w2 + (qy * uvZ - qz * uvY) * 2;\n        newDst[1] = y + uvY * w2 + (qz * uvX - qx * uvZ) * 2;\n        newDst[2] = z + uvZ * w2 + (qx * uvY - qy * uvX) * 2;\n        return newDst;\n    }\n    /**\n     * Returns the translation component of a 4-by-4 matrix as a vector with 3\n     * entries.\n     * @param m - The matrix.\n     * @param dst - vector to hold result. If not passed a new one is created.\n     * @returns The translation component of m.\n     */\n    function getTranslation(m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        newDst[0] = m[12];\n        newDst[1] = m[13];\n        newDst[2] = m[14];\n        return newDst;\n    }\n    /**\n     * Returns an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y, 2 = z;\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const off = axis * 4;\n        newDst[0] = m[off + 0];\n        newDst[1] = m[off + 1];\n        newDst[2] = m[off + 2];\n        return newDst;\n    }\n    /**\n     * Returns the scaling component of the matrix\n     * @param m - The Matrix\n     * @param dst - The vector to set. If not passed a new one is created.\n     */\n    function getScaling(m, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const xx = m[0];\n        const xy = m[1];\n        const xz = m[2];\n        const yx = m[4];\n        const yy = m[5];\n        const yz = m[6];\n        const zx = m[8];\n        const zy = m[9];\n        const zz = m[10];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n        return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns the rotated vector\n     */\n    function rotateX(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const p = [];\n        const r = [];\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n        r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n        //translate to correct position\n        newDst[0] = r[0] + b[0];\n        newDst[1] = r[1] + b[1];\n        newDst[2] = r[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns the rotated vector\n     */\n    function rotateY(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const p = [];\n        const r = [];\n        // translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n        // perform rotation\n        r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n        // translate to correct position\n        newDst[0] = r[0] + b[0];\n        newDst[1] = r[1] + b[1];\n        newDst[2] = r[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @param {ReadonlyVec3} a The vec3 point to rotate\n     * @param {ReadonlyVec3} b The origin of the rotation\n     * @param {Number} rad The angle of rotation in radians\n     * @param dst - The vector to set. If not passed a new one is created.\n     * @returns {vec3} out\n     */\n    function rotateZ(a, b, rad, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        const p = [];\n        const r = [];\n        // translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n        // perform rotation\n        r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n        r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n        r[2] = p[2];\n        // translate to correct position\n        newDst[0] = r[0] + b[0];\n        newDst[1] = r[1] + b[1];\n        newDst[2] = r[2] + b[2];\n        return newDst;\n    }\n    /**\n     * Treat a 3D vector as a direction and set it's length\n     *\n     * @param a The vec3 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        normalize(a, newDst);\n        return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec3 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        if (length(a) > maxLen) {\n            return setLength(a, maxLen, newDst);\n        }\n        return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n        const newDst = (dst ?? new Ctor(3));\n        return lerp(a, b, 0.5, newDst);\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        ceil,\n        floor,\n        round,\n        clamp,\n        add,\n        addScaled,\n        angle,\n        subtract,\n        sub,\n        equalsApproximately,\n        equals,\n        lerp,\n        lerpV,\n        max,\n        min,\n        mulScalar,\n        scale,\n        divScalar,\n        inverse,\n        invert,\n        cross,\n        dot,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        distance,\n        dist,\n        distanceSq,\n        distSq,\n        normalize,\n        negate,\n        copy,\n        clone,\n        multiply,\n        mul,\n        divide,\n        div,\n        random,\n        zero,\n        transformMat4,\n        transformMat4Upper3x3,\n        transformMat3,\n        transformQuat,\n        getTranslation,\n        getAxis,\n        getScaling,\n        rotateX,\n        rotateY,\n        rotateZ,\n        setLength,\n        truncate,\n        midpoint,\n    };\n}\nconst cache$3 = new Map();\nfunction getAPI$3(Ctor) {\n    let api = cache$3.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$3(Ctor);\n        cache$3.set(Ctor, api);\n    }\n    return api;\n}\n\n/**\n * Generates a typed API for Mat4\n * */\nfunction getAPIImpl$2(Ctor) {\n    const vec3 = getAPI$3(Ctor);\n    /**\n     * 4x4 Matrix math math functions.\n     *\n     * Almost all functions take an optional `newDst` argument. If it is not passed in the\n     * functions will create a new matrix. In other words you can do this\n     *\n     *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n     *\n     * or\n     *\n     *     const mat = mat4.create();\n     *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n     *\n     * The first style is often easier but depending on where it's used it generates garbage where\n     * as there is almost never allocation with the second style.\n     *\n     * It is always save to pass any matrix as the destination. So for example\n     *\n     *     const mat = mat4.identity();\n     *     const trans = mat4.translation([1, 2, 3]);\n     *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n     *\n     */\n    /**\n     * Create a Mat4 from values\n     *\n     * Note: Since passing in a raw JavaScript array\n     * is valid in all circumstances, if you want to\n     * force a JavaScript array into a Mat4's specified type\n     * it would be faster to use\n     *\n     * ```\n     * const m = mat4.clone(someJSArray);\n     * ```\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param v9 - value for element 9\n     * @param v10 - value for element 10\n     * @param v11 - value for element 11\n     * @param v12 - value for element 12\n     * @param v13 - value for element 13\n     * @param v14 - value for element 14\n     * @param v15 - value for element 15\n     * @returns created from values.\n     */\n    function create(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n        const newDst = new Ctor(16);\n        if (v0 !== undefined) {\n            newDst[0] = v0;\n            if (v1 !== undefined) {\n                newDst[1] = v1;\n                if (v2 !== undefined) {\n                    newDst[2] = v2;\n                    if (v3 !== undefined) {\n                        newDst[3] = v3;\n                        if (v4 !== undefined) {\n                            newDst[4] = v4;\n                            if (v5 !== undefined) {\n                                newDst[5] = v5;\n                                if (v6 !== undefined) {\n                                    newDst[6] = v6;\n                                    if (v7 !== undefined) {\n                                        newDst[7] = v7;\n                                        if (v8 !== undefined) {\n                                            newDst[8] = v8;\n                                            if (v9 !== undefined) {\n                                                newDst[9] = v9;\n                                                if (v10 !== undefined) {\n                                                    newDst[10] = v10;\n                                                    if (v11 !== undefined) {\n                                                        newDst[11] = v11;\n                                                        if (v12 !== undefined) {\n                                                            newDst[12] = v12;\n                                                            if (v13 !== undefined) {\n                                                                newDst[13] = v13;\n                                                                if (v14 !== undefined) {\n                                                                    newDst[14] = v14;\n                                                                    if (v15 !== undefined) {\n                                                                        newDst[15] = v15;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Sets the values of a Mat4\n     * Also see {@link mat4.create} and {@link mat4.copy}\n     *\n     * @param v0 - value for element 0\n     * @param v1 - value for element 1\n     * @param v2 - value for element 2\n     * @param v3 - value for element 3\n     * @param v4 - value for element 4\n     * @param v5 - value for element 5\n     * @param v6 - value for element 6\n     * @param v7 - value for element 7\n     * @param v8 - value for element 8\n     * @param v9 - value for element 9\n     * @param v10 - value for element 10\n     * @param v11 - value for element 11\n     * @param v12 - value for element 12\n     * @param v13 - value for element 13\n     * @param v14 - value for element 14\n     * @param v15 - value for element 15\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 created from values.\n     */\n    function set(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = v0;\n        newDst[1] = v1;\n        newDst[2] = v2;\n        newDst[3] = v3;\n        newDst[4] = v4;\n        newDst[5] = v5;\n        newDst[6] = v6;\n        newDst[7] = v7;\n        newDst[8] = v8;\n        newDst[9] = v9;\n        newDst[10] = v10;\n        newDst[11] = v11;\n        newDst[12] = v12;\n        newDst[13] = v13;\n        newDst[14] = v14;\n        newDst[15] = v15;\n        return newDst;\n    }\n    /**\n     * Creates a Mat4 from a Mat3\n     * @param m3 - source matrix\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 made from m3\n     */\n    function fromMat3(m3, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = m3[0];\n        newDst[1] = m3[1];\n        newDst[2] = m3[2];\n        newDst[3] = 0;\n        newDst[4] = m3[4];\n        newDst[5] = m3[5];\n        newDst[6] = m3[6];\n        newDst[7] = 0;\n        newDst[8] = m3[8];\n        newDst[9] = m3[9];\n        newDst[10] = m3[10];\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Creates a Mat4 rotation matrix from a quaternion\n     * @param q - quaternion to create matrix from\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns Mat4 made from q\n     */\n    function fromQuat(q, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const yx = y * x2;\n        const yy = y * y2;\n        const zx = z * x2;\n        const zy = z * y2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        newDst[0] = 1 - yy - zz;\n        newDst[1] = yx + wz;\n        newDst[2] = zx - wy;\n        newDst[3] = 0;\n        newDst[4] = yx - wz;\n        newDst[5] = 1 - xx - zz;\n        newDst[6] = zy + wx;\n        newDst[7] = 0;\n        newDst[8] = zx + wy;\n        newDst[9] = zy - wx;\n        newDst[10] = 1 - xx - yy;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Negates a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns -m.\n     */\n    function negate(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = -m[0];\n        newDst[1] = -m[1];\n        newDst[2] = -m[2];\n        newDst[3] = -m[3];\n        newDst[4] = -m[4];\n        newDst[5] = -m[5];\n        newDst[6] = -m[6];\n        newDst[7] = -m[7];\n        newDst[8] = -m[8];\n        newDst[9] = -m[9];\n        newDst[10] = -m[10];\n        newDst[11] = -m[11];\n        newDst[12] = -m[12];\n        newDst[13] = -m[13];\n        newDst[14] = -m[14];\n        newDst[15] = -m[15];\n        return newDst;\n    }\n    /**\n     * Copies a matrix. (same as {@link mat4.clone})\n     * Also see {@link mat4.create} and {@link mat4.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    function copy(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = m[0];\n        newDst[1] = m[1];\n        newDst[2] = m[2];\n        newDst[3] = m[3];\n        newDst[4] = m[4];\n        newDst[5] = m[5];\n        newDst[6] = m[6];\n        newDst[7] = m[7];\n        newDst[8] = m[8];\n        newDst[9] = m[9];\n        newDst[10] = m[10];\n        newDst[11] = m[11];\n        newDst[12] = m[12];\n        newDst[13] = m[13];\n        newDst[14] = m[14];\n        newDst[15] = m[15];\n        return newDst;\n    }\n    /**\n     * Copies a matrix (same as {@link mat4.copy})\n     * Also see {@link mat4.create} and {@link mat4.set}\n     * @param m - The matrix.\n     * @param dst - The matrix. If not passed a new one is created.\n     * @returns A copy of m.\n     */\n    const clone = copy;\n    /**\n     * Check if 2 matrices are approximately equal\n     * @param a - Operand matrix.\n     * @param b - Operand matrix.\n     * @returns true if matrices are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[3] - b[3]) < EPSILON &&\n            Math.abs(a[4] - b[4]) < EPSILON &&\n            Math.abs(a[5] - b[5]) < EPSILON &&\n            Math.abs(a[6] - b[6]) < EPSILON &&\n            Math.abs(a[7] - b[7]) < EPSILON &&\n            Math.abs(a[8] - b[8]) < EPSILON &&\n            Math.abs(a[9] - b[9]) < EPSILON &&\n            Math.abs(a[10] - b[10]) < EPSILON &&\n            Math.abs(a[11] - b[11]) < EPSILON &&\n            Math.abs(a[12] - b[12]) < EPSILON &&\n            Math.abs(a[13] - b[13]) < EPSILON &&\n            Math.abs(a[14] - b[14]) < EPSILON &&\n            Math.abs(a[15] - b[15]) < EPSILON;\n    }\n    /**\n     * Check if 2 matrices are exactly equal\n     * @param a - Operand matrix.\n     * @param b - Operand matrix.\n     * @returns true if matrices are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] &&\n            a[1] === b[1] &&\n            a[2] === b[2] &&\n            a[3] === b[3] &&\n            a[4] === b[4] &&\n            a[5] === b[5] &&\n            a[6] === b[6] &&\n            a[7] === b[7] &&\n            a[8] === b[8] &&\n            a[9] === b[9] &&\n            a[10] === b[10] &&\n            a[11] === b[11] &&\n            a[12] === b[12] &&\n            a[13] === b[13] &&\n            a[14] === b[14] &&\n            a[15] === b[15];\n    }\n    /**\n     * Creates a 4-by-4 identity matrix.\n     *\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A 4-by-4 identity matrix.\n     */\n    function identity(dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Takes the transpose of a matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The transpose of m.\n     */\n    function transpose(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        if (newDst === m) {\n            let t;\n            t = m[1];\n            m[1] = m[4];\n            m[4] = t;\n            t = m[2];\n            m[2] = m[8];\n            m[8] = t;\n            t = m[3];\n            m[3] = m[12];\n            m[12] = t;\n            t = m[6];\n            m[6] = m[9];\n            m[9] = t;\n            t = m[7];\n            m[7] = m[13];\n            m[13] = t;\n            t = m[11];\n            m[11] = m[14];\n            m[14] = t;\n            return newDst;\n        }\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        newDst[0] = m00;\n        newDst[1] = m10;\n        newDst[2] = m20;\n        newDst[3] = m30;\n        newDst[4] = m01;\n        newDst[5] = m11;\n        newDst[6] = m21;\n        newDst[7] = m31;\n        newDst[8] = m02;\n        newDst[9] = m12;\n        newDst[10] = m22;\n        newDst[11] = m32;\n        newDst[12] = m03;\n        newDst[13] = m13;\n        newDst[14] = m23;\n        newDst[15] = m33;\n        return newDst;\n    }\n    /**\n     * Computes the inverse of a 4-by-4 matrix.\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    function inverse(m, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        const tmp0 = m22 * m33;\n        const tmp1 = m32 * m23;\n        const tmp2 = m12 * m33;\n        const tmp3 = m32 * m13;\n        const tmp4 = m12 * m23;\n        const tmp5 = m22 * m13;\n        const tmp6 = m02 * m33;\n        const tmp7 = m32 * m03;\n        const tmp8 = m02 * m23;\n        const tmp9 = m22 * m03;\n        const tmp10 = m02 * m13;\n        const tmp11 = m12 * m03;\n        const tmp12 = m20 * m31;\n        const tmp13 = m30 * m21;\n        const tmp14 = m10 * m31;\n        const tmp15 = m30 * m11;\n        const tmp16 = m10 * m21;\n        const tmp17 = m20 * m11;\n        const tmp18 = m00 * m31;\n        const tmp19 = m30 * m01;\n        const tmp20 = m00 * m21;\n        const tmp21 = m20 * m01;\n        const tmp22 = m00 * m11;\n        const tmp23 = m10 * m01;\n        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n        const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n        newDst[0] = d * t0;\n        newDst[1] = d * t1;\n        newDst[2] = d * t2;\n        newDst[3] = d * t3;\n        newDst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n            (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n        newDst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n            (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n        newDst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n            (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n        newDst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n            (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n        newDst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n            (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n        newDst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n            (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n        newDst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n            (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n        newDst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n            (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n        newDst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n            (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n        newDst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n            (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n        newDst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n            (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n        newDst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n            (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n        return newDst;\n    }\n    /**\n     * Compute the determinant of a matrix\n     * @param m - the matrix\n     * @returns the determinant\n     */\n    function determinant(m) {\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        const tmp0 = m22 * m33;\n        const tmp1 = m32 * m23;\n        const tmp2 = m12 * m33;\n        const tmp3 = m32 * m13;\n        const tmp4 = m12 * m23;\n        const tmp5 = m22 * m13;\n        const tmp6 = m02 * m33;\n        const tmp7 = m32 * m03;\n        const tmp8 = m02 * m23;\n        const tmp9 = m22 * m03;\n        const tmp10 = m02 * m13;\n        const tmp11 = m12 * m03;\n        const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n            (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n        const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n            (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n        const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n            (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n        const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n            (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n        return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n    }\n    /**\n     * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n     * @param m - The matrix.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The inverse of m.\n     */\n    const invert = inverse;\n    /**\n     * Multiplies two 4-by-4 matrices with a on the left and b on the right\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const a00 = a[0];\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4 + 0];\n        const a11 = a[4 + 1];\n        const a12 = a[4 + 2];\n        const a13 = a[4 + 3];\n        const a20 = a[8 + 0];\n        const a21 = a[8 + 1];\n        const a22 = a[8 + 2];\n        const a23 = a[8 + 3];\n        const a30 = a[12 + 0];\n        const a31 = a[12 + 1];\n        const a32 = a[12 + 2];\n        const a33 = a[12 + 3];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4 + 0];\n        const b11 = b[4 + 1];\n        const b12 = b[4 + 2];\n        const b13 = b[4 + 3];\n        const b20 = b[8 + 0];\n        const b21 = b[8 + 1];\n        const b22 = b[8 + 2];\n        const b23 = b[8 + 3];\n        const b30 = b[12 + 0];\n        const b31 = b[12 + 1];\n        const b32 = b[12 + 2];\n        const b33 = b[12 + 3];\n        newDst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n        newDst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n        newDst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n        newDst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n        newDst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n        newDst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n        newDst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n        newDst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n        newDst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n        newDst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n        newDst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n        newDst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n        newDst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n        newDst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n        newDst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n        newDst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n        return newDst;\n    }\n    /**\n     * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n     * @param a - The matrix on the left.\n     * @param b - The matrix on the right.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix product of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Sets the translation component of a 4-by-4 matrix to the given\n     * vector.\n     * @param a - The matrix.\n     * @param v - The vector.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The matrix with translation set.\n     */\n    function setTranslation(a, v, dst) {\n        const newDst = (dst ?? identity());\n        if (a !== newDst) {\n            newDst[0] = a[0];\n            newDst[1] = a[1];\n            newDst[2] = a[2];\n            newDst[3] = a[3];\n            newDst[4] = a[4];\n            newDst[5] = a[5];\n            newDst[6] = a[6];\n            newDst[7] = a[7];\n            newDst[8] = a[8];\n            newDst[9] = a[9];\n            newDst[10] = a[10];\n            newDst[11] = a[11];\n        }\n        newDst[12] = v[0];\n        newDst[13] = v[1];\n        newDst[14] = v[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    ///**\n    // * Returns the translation component of a 4-by-4 matrix as a vector with 3\n    // * entries.\n    // * @param m - The matrix.\n    // * @param dst - vector to hold result. If not passed a new one is created.\n    // * @returns The translation component of m.\n    // */\n    function getTranslation(m, dst) {\n        const newDst = (dst ?? vec3.create());\n        newDst[0] = m[12];\n        newDst[1] = m[13];\n        newDst[2] = m[14];\n        return newDst;\n    }\n    /**\n     * Returns an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param axis - The axis 0 = x, 1 = y, 2 = z;\n     * @returns The axis component of m.\n     */\n    function getAxis(m, axis, dst) {\n        const newDst = (dst ?? vec3.create());\n        const off = axis * 4;\n        newDst[0] = m[off + 0];\n        newDst[1] = m[off + 1];\n        newDst[2] = m[off + 2];\n        return newDst;\n    }\n    /**\n     * Sets an axis of a 4x4 matrix as a vector with 3 entries\n     * @param m - The matrix.\n     * @param v - the axis vector\n     * @param axis - The axis  0 = x, 1 = y, 2 = z;\n     * @param dst - The matrix to set. If not passed a new one is created.\n     * @returns The matrix with axis set.\n     */\n    function setAxis(m, v, axis, dst) {\n        const newDst = (dst === m) ? dst : copy(m, dst);\n        const off = axis * 4;\n        newDst[off + 0] = v[0];\n        newDst[off + 1] = v[1];\n        newDst[off + 2] = v[2];\n        return newDst;\n    }\n    ///**\n    // * Returns the scaling component of the matrix\n    // * @param m - The Matrix\n    // * @param dst - The vector to set. If not passed a new one is created.\n    // */\n    function getScaling(m, dst) {\n        const newDst = (dst ?? vec3.create());\n        const xx = m[0];\n        const xy = m[1];\n        const xz = m[2];\n        const yx = m[4];\n        const yy = m[5];\n        const yz = m[6];\n        const zx = m[8];\n        const zy = m[9];\n        const zz = m[10];\n        newDst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n        newDst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n        newDst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 perspective transformation matrix given the angular height\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n     * arguments define a frustum extending in the negative z direction.  The given\n     * angle is the vertical angle of the frustum, and the horizontal angle is\n     * determined to produce the given aspect ratio.  The arguments near and far are\n     * the distances to the near and far clipping planes.  Note that near and far\n     * are not z coordinates, but rather they are distances along the negative\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n     * from 0 to 1 in the z dimension.\n     *\n     * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n     * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n     * otherwise.\n     *\n     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n     * @param aspect - The aspect ratio width / height.\n     * @param zNear - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param zFar - The depth (negative z coordinate)\n     *     of the far clipping plane.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The perspective matrix.\n     */\n    function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n        newDst[0] = f / aspect;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = f;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[15] = 0;\n        if (Number.isFinite(zFar)) {\n            const rangeInv = 1 / (zNear - zFar);\n            newDst[10] = zFar * rangeInv;\n            newDst[14] = zFar * zNear * rangeInv;\n        }\n        else {\n            newDst[10] = -1;\n            newDst[14] = -zNear;\n        }\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 reverse-z perspective transformation matrix given the angular height\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n     * arguments define a frustum extending in the negative z direction.  The given\n     * angle is the vertical angle of the frustum, and the horizontal angle is\n     * determined to produce the given aspect ratio.  The arguments near and far are\n     * the distances to the near and far clipping planes.  Note that near and far\n     * are not z coordinates, but rather they are distances along the negative\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n     * from 1 (at -zNear) to 0 (at -zFar) in the z dimension.\n     *\n     * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n     * @param aspect - The aspect ratio width / height.\n     * @param zNear - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param zFar - The depth (negative z coordinate)\n     *     of the far clipping plane. (default = Infinity)\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The perspective matrix.\n     */ function perspectiveReverseZ(fieldOfViewYInRadians, aspect, zNear, zFar = Infinity, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const f = 1 / Math.tan(fieldOfViewYInRadians * 0.5);\n        newDst[0] = f / aspect;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = f;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[15] = 0;\n        if (zFar === Infinity) {\n            newDst[10] = 0;\n            newDst[14] = zNear;\n        }\n        else {\n            const rangeInv = 1 / (zFar - zNear);\n            newDst[10] = zNear * rangeInv;\n            newDst[14] = zFar * zNear * rangeInv;\n        }\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n     * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n     * and 0 to +1 in z.\n     * @param left - Left side of the near clipping plane viewport.\n     * @param right - Right side of the near clipping plane viewport.\n     * @param bottom - Bottom of the near clipping plane viewport.\n     * @param top - Top of the near clipping plane viewport.\n     * @param near - The depth (negative z coordinate)\n     *     of the near clipping plane.\n     * @param far - The depth (negative z coordinate)\n     *     of the far clipping plane.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The orthographic projection matrix.\n     */\n    function ortho(left, right, bottom, top, near, far, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = 2 / (right - left);\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 2 / (top - bottom);\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1 / (near - far);\n        newDst[11] = 0;\n        newDst[12] = (right + left) / (left - right);\n        newDst[13] = (top + bottom) / (bottom - top);\n        newDst[14] = near / (near - far);\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 perspective transformation matrix given the left, right,\n     * top, bottom, near and far clipping planes. The arguments define a frustum\n     * extending in the negative z direction. The arguments near and far are the\n     * distances to the near and far clipping planes. Note that near and far are not\n     * z coordinates, but rather they are distances along the negative z-axis. The\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\n     * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n     * dimension.\n     * @param left - The x coordinate of the left plane of the box.\n     * @param right - The x coordinate of the right plane of the box.\n     * @param bottom - The y coordinate of the bottom plane of the box.\n     * @param top - The y coordinate of the right plane of the box.\n     * @param near - The negative z coordinate of the near plane of the box.\n     * @param far - The negative z coordinate of the far plane of the box.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The perspective projection matrix.\n     */\n    function frustum(left, right, bottom, top, near, far, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const dx = (right - left);\n        const dy = (top - bottom);\n        const dz = (near - far);\n        newDst[0] = 2 * near / dx;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 2 * near / dy;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = (left + right) / dx;\n        newDst[9] = (top + bottom) / dy;\n        newDst[10] = far / dz;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = near * far / dz;\n        newDst[15] = 0;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 reverse-z perspective transformation matrix given the left, right,\n     * top, bottom, near and far clipping planes. The arguments define a frustum\n     * extending in the negative z direction. The arguments near and far are the\n     * distances to the near and far clipping planes. Note that near and far are not\n     * z coordinates, but rather they are distances along the negative z-axis. The\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\n     * box extending from -1 to 1 in the x and y dimensions and from 1 (-near) to 0 (-far) in the z\n     * dimension.\n     * @param left - The x coordinate of the left plane of the box.\n     * @param right - The x coordinate of the right plane of the box.\n     * @param bottom - The y coordinate of the bottom plane of the box.\n     * @param top - The y coordinate of the right plane of the box.\n     * @param near - The negative z coordinate of the near plane of the box.\n     * @param far - The negative z coordinate of the far plane of the box.\n     * @param dst - Output matrix. If not passed a new one is created.\n     * @returns The perspective projection matrix.\n     */\n    function frustumReverseZ(left, right, bottom, top, near, far = Infinity, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const dx = (right - left);\n        const dy = (top - bottom);\n        newDst[0] = 2 * near / dx;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 2 * near / dy;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = (left + right) / dx;\n        newDst[9] = (top + bottom) / dy;\n        newDst[11] = -1;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[15] = 0;\n        if (far === Infinity) {\n            newDst[10] = 0;\n            newDst[14] = near;\n        }\n        else {\n            const rangeInv = 1 / (far - near);\n            newDst[10] = near * rangeInv;\n            newDst[14] = far * near * rangeInv;\n        }\n        return newDst;\n    }\n    const xAxis = vec3.create();\n    const yAxis = vec3.create();\n    const zAxis = vec3.create();\n    /**\n     * Computes a 4-by-4 aim transformation.\n     *\n     * This is a matrix which positions an object aiming down positive Z.\n     * toward the target.\n     *\n     * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n     *\n     * @param position - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The aim matrix.\n     */\n    function aim(position, target, up, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        vec3.normalize(vec3.subtract(target, position, zAxis), zAxis);\n        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n        newDst[0] = xAxis[0];\n        newDst[1] = xAxis[1];\n        newDst[2] = xAxis[2];\n        newDst[3] = 0;\n        newDst[4] = yAxis[0];\n        newDst[5] = yAxis[1];\n        newDst[6] = yAxis[2];\n        newDst[7] = 0;\n        newDst[8] = zAxis[0];\n        newDst[9] = zAxis[1];\n        newDst[10] = zAxis[2];\n        newDst[11] = 0;\n        newDst[12] = position[0];\n        newDst[13] = position[1];\n        newDst[14] = position[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 camera aim transformation.\n     *\n     * This is a matrix which positions an object aiming down negative Z.\n     * toward the target.\n     *\n     * Note: this is the inverse of `lookAt`\n     *\n     * @param eye - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The aim matrix.\n     */\n    function cameraAim(eye, target, up, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n        newDst[0] = xAxis[0];\n        newDst[1] = xAxis[1];\n        newDst[2] = xAxis[2];\n        newDst[3] = 0;\n        newDst[4] = yAxis[0];\n        newDst[5] = yAxis[1];\n        newDst[6] = yAxis[2];\n        newDst[7] = 0;\n        newDst[8] = zAxis[0];\n        newDst[9] = zAxis[1];\n        newDst[10] = zAxis[2];\n        newDst[11] = 0;\n        newDst[12] = eye[0];\n        newDst[13] = eye[1];\n        newDst[14] = eye[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Computes a 4-by-4 view transformation.\n     *\n     * This is a view matrix which transforms all other objects\n     * to be in the space of the view defined by the parameters.\n     *\n     * @param eye - The position of the object.\n     * @param target - The position meant to be aimed at.\n     * @param up - A vector pointing up.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The look-at matrix.\n     */\n    function lookAt(eye, target, up, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        vec3.normalize(vec3.subtract(eye, target, zAxis), zAxis);\n        vec3.normalize(vec3.cross(up, zAxis, xAxis), xAxis);\n        vec3.normalize(vec3.cross(zAxis, xAxis, yAxis), yAxis);\n        newDst[0] = xAxis[0];\n        newDst[1] = yAxis[0];\n        newDst[2] = zAxis[0];\n        newDst[3] = 0;\n        newDst[4] = xAxis[1];\n        newDst[5] = yAxis[1];\n        newDst[6] = zAxis[1];\n        newDst[7] = 0;\n        newDst[8] = xAxis[2];\n        newDst[9] = yAxis[2];\n        newDst[10] = zAxis[2];\n        newDst[11] = 0;\n        newDst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n        newDst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n        newDst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which translates by the given vector v.\n     * @param v - The vector by\n     *     which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translation matrix.\n     */\n    function translation(v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        newDst[11] = 0;\n        newDst[12] = v[0];\n        newDst[13] = v[1];\n        newDst[14] = v[2];\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Translates the given 4-by-4 matrix by the given vector v.\n     * @param m - The matrix.\n     * @param v - The vector by\n     *     which to translate.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The translated matrix.\n     */\n    function translate(m, v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const m00 = m[0];\n        const m01 = m[1];\n        const m02 = m[2];\n        const m03 = m[3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const m30 = m[3 * 4 + 0];\n        const m31 = m[3 * 4 + 1];\n        const m32 = m[3 * 4 + 2];\n        const m33 = m[3 * 4 + 3];\n        if (m !== newDst) {\n            newDst[0] = m00;\n            newDst[1] = m01;\n            newDst[2] = m02;\n            newDst[3] = m03;\n            newDst[4] = m10;\n            newDst[5] = m11;\n            newDst[6] = m12;\n            newDst[7] = m13;\n            newDst[8] = m20;\n            newDst[9] = m21;\n            newDst[10] = m22;\n            newDst[11] = m23;\n        }\n        newDst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n        newDst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n        newDst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n        newDst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationX(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = 1;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = c;\n        newDst[6] = s;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = -s;\n        newDst[10] = c;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the x-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateX(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m10 = m[4];\n        const m11 = m[5];\n        const m12 = m[6];\n        const m13 = m[7];\n        const m20 = m[8];\n        const m21 = m[9];\n        const m22 = m[10];\n        const m23 = m[11];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[4] = c * m10 + s * m20;\n        newDst[5] = c * m11 + s * m21;\n        newDst[6] = c * m12 + s * m22;\n        newDst[7] = c * m13 + s * m23;\n        newDst[8] = c * m20 - s * m10;\n        newDst[9] = c * m21 - s * m11;\n        newDst[10] = c * m22 - s * m12;\n        newDst[11] = c * m23 - s * m13;\n        if (m !== newDst) {\n            newDst[0] = m[0];\n            newDst[1] = m[1];\n            newDst[2] = m[2];\n            newDst[3] = m[3];\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationY(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = 0;\n        newDst[2] = -s;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = 1;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = s;\n        newDst[9] = 0;\n        newDst[10] = c;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the y-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateY(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m20 = m[2 * 4 + 0];\n        const m21 = m[2 * 4 + 1];\n        const m22 = m[2 * 4 + 2];\n        const m23 = m[2 * 4 + 3];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 - s * m20;\n        newDst[1] = c * m01 - s * m21;\n        newDst[2] = c * m02 - s * m22;\n        newDst[3] = c * m03 - s * m23;\n        newDst[8] = c * m20 + s * m00;\n        newDst[9] = c * m21 + s * m01;\n        newDst[10] = c * m22 + s * m02;\n        newDst[11] = c * m23 + s * m03;\n        if (m !== newDst) {\n            newDst[4] = m[4];\n            newDst[5] = m[5];\n            newDst[6] = m[6];\n            newDst[7] = m[7];\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotation matrix.\n     */\n    function rotationZ(angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c;\n        newDst[1] = s;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = -s;\n        newDst[5] = c;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = 1;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the z-axis by the given\n     * angle.\n     * @param m - The matrix.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function rotateZ(m, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const m00 = m[0 * 4 + 0];\n        const m01 = m[0 * 4 + 1];\n        const m02 = m[0 * 4 + 2];\n        const m03 = m[0 * 4 + 3];\n        const m10 = m[1 * 4 + 0];\n        const m11 = m[1 * 4 + 1];\n        const m12 = m[1 * 4 + 2];\n        const m13 = m[1 * 4 + 3];\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        newDst[0] = c * m00 + s * m10;\n        newDst[1] = c * m01 + s * m11;\n        newDst[2] = c * m02 + s * m12;\n        newDst[3] = c * m03 + s * m13;\n        newDst[4] = c * m10 - s * m00;\n        newDst[5] = c * m11 - s * m01;\n        newDst[6] = c * m12 - s * m02;\n        newDst[7] = c * m13 - s * m03;\n        if (m !== newDst) {\n            newDst[8] = m[8];\n            newDst[9] = m[9];\n            newDst[10] = m[10];\n            newDst[11] = m[11];\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the given axis by the given\n     * angle.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A matrix which rotates angle radians\n     *     around the axis.\n     */\n    function axisRotation(axis, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        let x = axis[0];\n        let y = axis[1];\n        let z = axis[2];\n        const n = Math.sqrt(x * x + y * y + z * z);\n        x /= n;\n        y /= n;\n        z /= n;\n        const xx = x * x;\n        const yy = y * y;\n        const zz = z * z;\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        const oneMinusCosine = 1 - c;\n        newDst[0] = xx + (1 - xx) * c;\n        newDst[1] = x * y * oneMinusCosine + z * s;\n        newDst[2] = x * z * oneMinusCosine - y * s;\n        newDst[3] = 0;\n        newDst[4] = x * y * oneMinusCosine - z * s;\n        newDst[5] = yy + (1 - yy) * c;\n        newDst[6] = y * z * oneMinusCosine + x * s;\n        newDst[7] = 0;\n        newDst[8] = x * z * oneMinusCosine + y * s;\n        newDst[9] = y * z * oneMinusCosine - x * s;\n        newDst[10] = zz + (1 - zz) * c;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which rotates around the given axis by the given\n     * angle. (same as axisRotation)\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns A matrix which rotates angle radians\n     *     around the axis.\n     */\n    const rotation = axisRotation;\n    /**\n     * Rotates the given 4-by-4 matrix around the given axis by the\n     * given angle.\n     * @param m - The matrix.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    function axisRotate(m, axis, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        let x = axis[0];\n        let y = axis[1];\n        let z = axis[2];\n        const n = Math.sqrt(x * x + y * y + z * z);\n        x /= n;\n        y /= n;\n        z /= n;\n        const xx = x * x;\n        const yy = y * y;\n        const zz = z * z;\n        const c = Math.cos(angleInRadians);\n        const s = Math.sin(angleInRadians);\n        const oneMinusCosine = 1 - c;\n        const r00 = xx + (1 - xx) * c;\n        const r01 = x * y * oneMinusCosine + z * s;\n        const r02 = x * z * oneMinusCosine - y * s;\n        const r10 = x * y * oneMinusCosine - z * s;\n        const r11 = yy + (1 - yy) * c;\n        const r12 = y * z * oneMinusCosine + x * s;\n        const r20 = x * z * oneMinusCosine + y * s;\n        const r21 = y * z * oneMinusCosine - x * s;\n        const r22 = zz + (1 - zz) * c;\n        const m00 = m[0];\n        const m01 = m[1];\n        const m02 = m[2];\n        const m03 = m[3];\n        const m10 = m[4];\n        const m11 = m[5];\n        const m12 = m[6];\n        const m13 = m[7];\n        const m20 = m[8];\n        const m21 = m[9];\n        const m22 = m[10];\n        const m23 = m[11];\n        newDst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n        newDst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n        newDst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n        newDst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n        newDst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n        newDst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n        newDst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n        newDst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n        newDst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n        newDst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n        newDst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n        newDst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n        if (m !== newDst) {\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Rotates the given 4-by-4 matrix around the given axis by the\n     * given angle. (same as rotate)\n     * @param m - The matrix.\n     * @param axis - The axis\n     *     about which to rotate.\n     * @param angleInRadians - The angle by which to rotate (in radians).\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The rotated matrix.\n     */\n    const rotate = axisRotate;\n    /**\n     * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n     * the corresponding entry in the given vector; assumes the vector has three\n     * entries.\n     * @param v - A vector of\n     *     three entries specifying the factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function scaling(v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = v[0];\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = v[1];\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = v[2];\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 4-by-4 matrix in each dimension by an amount\n     * given by the corresponding entry in the given vector; assumes the vector has\n     * three entries.\n     * @param m - The matrix to be modified.\n     * @param v - A vector of three entries specifying the\n     *     factor by which to scale in each dimension.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function scale(m, v, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        newDst[0] = v0 * m[0 * 4 + 0];\n        newDst[1] = v0 * m[0 * 4 + 1];\n        newDst[2] = v0 * m[0 * 4 + 2];\n        newDst[3] = v0 * m[0 * 4 + 3];\n        newDst[4] = v1 * m[1 * 4 + 0];\n        newDst[5] = v1 * m[1 * 4 + 1];\n        newDst[6] = v1 * m[1 * 4 + 2];\n        newDst[7] = v1 * m[1 * 4 + 3];\n        newDst[8] = v2 * m[2 * 4 + 0];\n        newDst[9] = v2 * m[2 * 4 + 1];\n        newDst[10] = v2 * m[2 * 4 + 2];\n        newDst[11] = v2 * m[2 * 4 + 3];\n        if (m !== newDst) {\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    /**\n     * Creates a 4-by-4 matrix which scales a uniform amount in each dimension.\n     * @param s - the amount to scale\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaling matrix.\n     */\n    function uniformScaling(s, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = s;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        newDst[4] = 0;\n        newDst[5] = s;\n        newDst[6] = 0;\n        newDst[7] = 0;\n        newDst[8] = 0;\n        newDst[9] = 0;\n        newDst[10] = s;\n        newDst[11] = 0;\n        newDst[12] = 0;\n        newDst[13] = 0;\n        newDst[14] = 0;\n        newDst[15] = 1;\n        return newDst;\n    }\n    /**\n     * Scales the given 4-by-4 matrix in each dimension by a uniform scale.\n     * @param m - The matrix to be modified.\n     * @param s - The amount to scale.\n     * @param dst - matrix to hold result. If not passed a new one is created.\n     * @returns The scaled matrix.\n     */\n    function uniformScale(m, s, dst) {\n        const newDst = (dst ?? new Ctor(16));\n        newDst[0] = s * m[0 * 4 + 0];\n        newDst[1] = s * m[0 * 4 + 1];\n        newDst[2] = s * m[0 * 4 + 2];\n        newDst[3] = s * m[0 * 4 + 3];\n        newDst[4] = s * m[1 * 4 + 0];\n        newDst[5] = s * m[1 * 4 + 1];\n        newDst[6] = s * m[1 * 4 + 2];\n        newDst[7] = s * m[1 * 4 + 3];\n        newDst[8] = s * m[2 * 4 + 0];\n        newDst[9] = s * m[2 * 4 + 1];\n        newDst[10] = s * m[2 * 4 + 2];\n        newDst[11] = s * m[2 * 4 + 3];\n        if (m !== newDst) {\n            newDst[12] = m[12];\n            newDst[13] = m[13];\n            newDst[14] = m[14];\n            newDst[15] = m[15];\n        }\n        return newDst;\n    }\n    return {\n        create,\n        set,\n        fromMat3,\n        fromQuat,\n        negate,\n        copy,\n        clone,\n        equalsApproximately,\n        equals,\n        identity,\n        transpose,\n        inverse,\n        determinant,\n        invert,\n        multiply,\n        mul,\n        setTranslation,\n        getTranslation,\n        getAxis,\n        setAxis,\n        getScaling,\n        perspective,\n        perspectiveReverseZ,\n        ortho,\n        frustum,\n        frustumReverseZ,\n        aim,\n        cameraAim,\n        lookAt,\n        translation,\n        translate,\n        rotationX,\n        rotateX,\n        rotationY,\n        rotateY,\n        rotationZ,\n        rotateZ,\n        axisRotation,\n        rotation,\n        axisRotate,\n        rotate,\n        scaling,\n        scale,\n        uniformScaling,\n        uniformScale,\n    };\n}\nconst cache$2 = new Map();\nfunction getAPI$2(Ctor) {\n    let api = cache$2.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$2(Ctor);\n        cache$2.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Qud\n * */\nfunction getAPIImpl$1(Ctor) {\n    const vec3 = getAPI$3(Ctor);\n    /**\n     * Creates a quat4; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param w - Initial w value.\n     * @returns the created vector\n     */\n    function create(x, y, z, w) {\n        const newDst = new Ctor(4);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n                if (z !== undefined) {\n                    newDst[2] = z;\n                    if (w !== undefined) {\n                        newDst[3] = w;\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param z - Initial w value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Quat\n     * Also see {@link quat.create} and {@link quat.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param w fourth value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, w, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = x;\n        newDst[1] = y;\n        newDst[2] = z;\n        newDst[3] = w;\n        return newDst;\n    }\n    /**\n     * Sets a quaternion from the given angle and  axis,\n     * then returns it.\n     *\n     * @param axis - the axis to rotate around\n     * @param angleInRadians - the angle\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The quaternion that represents the given axis and angle\n     **/\n    function fromAxisAngle(axis, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const s = Math.sin(halfAngle);\n        newDst[0] = s * axis[0];\n        newDst[1] = s * axis[1];\n        newDst[2] = s * axis[2];\n        newDst[3] = Math.cos(halfAngle);\n        return newDst;\n    }\n    /**\n     * Gets the rotation axis and angle\n     * @param q - quaternion to compute from\n     * @param dst - Vec3 to hold result. If not passed in a new one is created.\n     * @return angle and axis\n     */\n    function toAxisAngle(q, dst) {\n        const newDst = (dst ?? vec3.create(3));\n        const angle = Math.acos(q[3]) * 2;\n        const s = Math.sin(angle * 0.5);\n        if (s > EPSILON) {\n            newDst[0] = q[0] / s;\n            newDst[1] = q[1] / s;\n            newDst[2] = q[2] / s;\n        }\n        else {\n            newDst[0] = 1;\n            newDst[1] = 0;\n            newDst[2] = 0;\n        }\n        return { angle, axis: newDst };\n    }\n    /**\n     * Returns the angle in degrees between two rotations a and b.\n     * @param a - quaternion a\n     * @param b - quaternion b\n     * @return angle in radians between the two quaternions\n     */\n    function angle(a, b) {\n        const d = dot(a, b);\n        return Math.acos(2 * d * d - 1);\n    }\n    /**\n     * Multiplies two quaternions\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const aw = a[3];\n        const bx = b[0];\n        const by = b[1];\n        const bz = b[2];\n        const bw = b[3];\n        newDst[0] = ax * bw + aw * bx + ay * bz - az * by;\n        newDst[1] = ay * bw + aw * by + az * bx - ax * bz;\n        newDst[2] = az * bw + aw * bz + ax * by - ay * bx;\n        newDst[3] = aw * bw - ax * bx - ay * by - az * bz;\n        return newDst;\n    }\n    /**\n     * Multiplies two quaternions\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    const mul = multiply;\n    /**\n     * Rotates the given quaternion around the X axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateX(q, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n        const bx = Math.sin(halfAngle);\n        const bw = Math.cos(halfAngle);\n        newDst[0] = qx * bw + qw * bx;\n        newDst[1] = qy * bw + qz * bx;\n        newDst[2] = qz * bw - qy * bx;\n        newDst[3] = qw * bw - qx * bx;\n        return newDst;\n    }\n    /**\n     * Rotates the given quaternion around the Y axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateY(q, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n        const by = Math.sin(halfAngle);\n        const bw = Math.cos(halfAngle);\n        newDst[0] = qx * bw - qz * by;\n        newDst[1] = qy * bw + qw * by;\n        newDst[2] = qz * bw + qx * by;\n        newDst[3] = qw * bw - qy * by;\n        return newDst;\n    }\n    /**\n     * Rotates the given quaternion around the Z axis by the given angle.\n     * @param q - quaternion to rotate\n     * @param angleInRadians - The angle by which to rotate\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function rotateZ(q, angleInRadians, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const halfAngle = angleInRadians * 0.5;\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n        const bz = Math.sin(halfAngle);\n        const bw = Math.cos(halfAngle);\n        newDst[0] = qx * bw + qy * bz;\n        newDst[1] = qy * bw - qx * bz;\n        newDst[2] = qz * bw + qw * bz;\n        newDst[3] = qw * bw - qz * bz;\n        return newDst;\n    }\n    /**\n     * Spherically linear interpolate between two quaternions\n     *\n     * @param a - starting value\n     * @param b - ending value\n     * @param t - value where 0 = a and 1 = b\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the result of a * b\n     */\n    function slerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const ax = a[0];\n        const ay = a[1];\n        const az = a[2];\n        const aw = a[3];\n        let bx = b[0];\n        let by = b[1];\n        let bz = b[2];\n        let bw = b[3];\n        let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n        if (cosOmega < 0) {\n            cosOmega = -cosOmega;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n        let scale0;\n        let scale1;\n        if (1.0 - cosOmega > EPSILON) {\n            const omega = Math.acos(cosOmega);\n            const sinOmega = Math.sin(omega);\n            scale0 = Math.sin((1 - t) * omega) / sinOmega;\n            scale1 = Math.sin(t * omega) / sinOmega;\n        }\n        else {\n            scale0 = 1.0 - t;\n            scale1 = t;\n        }\n        newDst[0] = scale0 * ax + scale1 * bx;\n        newDst[1] = scale0 * ay + scale1 * by;\n        newDst[2] = scale0 * az + scale1 * bz;\n        newDst[3] = scale0 * aw + scale1 * bw;\n        return newDst;\n    }\n    /**\n     * Compute the inverse of a quaternion\n     *\n     * @param q - quaternion to compute the inverse of\n     * @returns A quaternion that is the result of a * b\n     */\n    function inverse(q, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const a0 = q[0];\n        const a1 = q[1];\n        const a2 = q[2];\n        const a3 = q[3];\n        const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n        const invDot = dot ? 1 / dot : 0;\n        newDst[0] = -a0 * invDot;\n        newDst[1] = -a1 * invDot;\n        newDst[2] = -a2 * invDot;\n        newDst[3] = a3 * invDot;\n        return newDst;\n    }\n    /**\n     * Compute the conjugate of a quaternion\n     * For quaternions with a magnitude of 1 (a unit quaternion)\n     * this returns the same as the inverse but is faster to calculate.\n     *\n     * @param q - quaternion to compute the conjugate of.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The conjugate of q\n     */\n    function conjugate(q, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = -q[0];\n        newDst[1] = -q[1];\n        newDst[2] = -q[2];\n        newDst[3] = q[3];\n        return newDst;\n    }\n    /**\n     * Creates a quaternion from the given rotation matrix.\n     *\n     * The created quaternion is not normalized.\n     *\n     * @param m - rotation matrix\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns the result\n     */\n    function fromMat(m, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        /*\n        0 1 2\n        3 4 5\n        6 7 8\n      \n        0 1 2\n        4 5 6\n        8 9 10\n         */\n        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n        // article \"Quaternion Calculus and Fast Animation\".\n        const trace = m[0] + m[5] + m[10];\n        if (trace > 0.0) {\n            // |w| > 1/2, may as well choose w > 1/2\n            const root = Math.sqrt(trace + 1); // 2w\n            newDst[3] = 0.5 * root;\n            const invRoot = 0.5 / root; // 1/(4w)\n            newDst[0] = (m[6] - m[9]) * invRoot;\n            newDst[1] = (m[8] - m[2]) * invRoot;\n            newDst[2] = (m[1] - m[4]) * invRoot;\n        }\n        else {\n            // |w| <= 1/2\n            let i = 0;\n            if (m[5] > m[0]) {\n                i = 1;\n            }\n            if (m[10] > m[i * 4 + i]) {\n                i = 2;\n            }\n            const j = (i + 1) % 3;\n            const k = (i + 2) % 3;\n            const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n            newDst[i] = 0.5 * root;\n            const invRoot = 0.5 / root;\n            newDst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n            newDst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n            newDst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n        }\n        return newDst;\n    }\n    /**\n     * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n     *\n     * @param xAngleInRadians - angle to rotate around X axis in radians.\n     * @param yAngleInRadians - angle to rotate around Y axis in radians.\n     * @param zAngleInRadians - angle to rotate around Z axis in radians.\n     * @param order - order to apply euler angles\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n     */\n    function fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const xHalfAngle = xAngleInRadians * 0.5;\n        const yHalfAngle = yAngleInRadians * 0.5;\n        const zHalfAngle = zAngleInRadians * 0.5;\n        const sx = Math.sin(xHalfAngle);\n        const cx = Math.cos(xHalfAngle);\n        const sy = Math.sin(yHalfAngle);\n        const cy = Math.cos(yHalfAngle);\n        const sz = Math.sin(zHalfAngle);\n        const cz = Math.cos(zHalfAngle);\n        switch (order) {\n            case 'xyz':\n                newDst[0] = sx * cy * cz + cx * sy * sz;\n                newDst[1] = cx * sy * cz - sx * cy * sz;\n                newDst[2] = cx * cy * sz + sx * sy * cz;\n                newDst[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case 'xzy':\n                newDst[0] = sx * cy * cz - cx * sy * sz;\n                newDst[1] = cx * sy * cz - sx * cy * sz;\n                newDst[2] = cx * cy * sz + sx * sy * cz;\n                newDst[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            case 'yxz':\n                newDst[0] = sx * cy * cz + cx * sy * sz;\n                newDst[1] = cx * sy * cz - sx * cy * sz;\n                newDst[2] = cx * cy * sz - sx * sy * cz;\n                newDst[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            case 'yzx':\n                newDst[0] = sx * cy * cz + cx * sy * sz;\n                newDst[1] = cx * sy * cz + sx * cy * sz;\n                newDst[2] = cx * cy * sz - sx * sy * cz;\n                newDst[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case 'zxy':\n                newDst[0] = sx * cy * cz - cx * sy * sz;\n                newDst[1] = cx * sy * cz + sx * cy * sz;\n                newDst[2] = cx * cy * sz + sx * sy * cz;\n                newDst[3] = cx * cy * cz - sx * sy * sz;\n                break;\n            case 'zyx':\n                newDst[0] = sx * cy * cz - cx * sy * sz;\n                newDst[1] = cx * sy * cz + sx * cy * sz;\n                newDst[2] = cx * cy * sz - sx * sy * cz;\n                newDst[3] = cx * cy * cz + sx * sy * sz;\n                break;\n            default:\n                throw new Error(`Unknown rotation order: ${order}`);\n        }\n        return newDst;\n    }\n    /**\n     * Copies a quaternion. (same as {@link quat.clone})\n     * Also see {@link quat.create} and {@link quat.set}\n     * @param q - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is a copy of q\n     */\n    function copy(q, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = q[0];\n        newDst[1] = q[1];\n        newDst[2] = q[2];\n        newDst[3] = q[3];\n        return newDst;\n    }\n    /**\n     * Clones a quaternion. (same as {@link quat.copy})\n     * Also see {@link quat.create} and {@link quat.set}\n     * @param q - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A copy of q.\n     */\n    const clone = copy;\n    /**\n     * Adds two quaternions; assumes a and b have the same dimension.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        newDst[3] = a[3] + b[3];\n        return newDst;\n    }\n    /**\n     * Subtracts two quaternions.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        newDst[2] = a[2] - b[2];\n        newDst[3] = a[3] - b[3];\n        return newDst;\n    }\n    /**\n     * Subtracts two quaternions.\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns A quaternion that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Multiplies a quaternion by a scalar.\n     * @param v - The quaternion.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        newDst[2] = v[2] * k;\n        newDst[3] = v[3] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a quaternion by a scalar. (same as mulScalar)\n     * @param v - The quaternion.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The scaled quaternion.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        newDst[2] = v[2] / k;\n        newDst[3] = v[3] / k;\n        return newDst;\n    }\n    /**\n     * Computes the dot product of two quaternions\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n    }\n    /**\n     * Performs linear interpolation on two quaternions.\n     * Given quaternions a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @param t - Interpolation coefficient.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        newDst[2] = a[2] + t * (b[2] - a[2]);\n        newDst[3] = a[3] + t * (b[3] - a[3]);\n        return newDst;\n    }\n    /**\n     * Computes the length of quaternion\n     * @param v - quaternion.\n     * @returns length of quaternion.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    }\n    /**\n     * Computes the length of quaternion (same as length)\n     * @param v - quaternion.\n     * @returns length of quaternion.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of quaternion\n     * @param v - quaternion.\n     * @returns square of the length of quaternion.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n    }\n    /**\n     * Computes the square of the length of quaternion (same as lengthSq)\n     * @param v - quaternion.\n     * @returns square of the length of quaternion.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Divides a quaternion by its Euclidean length and returns the quotient.\n     * @param v - The quaternion.\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns The normalized quaternion.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n            newDst[2] = v2 / len;\n            newDst[3] = v3 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n            newDst[3] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Check if 2 quaternions are approximately equal\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns true if quaternions are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[3] - b[3]) < EPSILON;\n    }\n    /**\n     * Check if 2 quaternions are exactly equal\n     * @param a - Operand quaternion.\n     * @param b - Operand quaternion.\n     * @returns true if quaternions are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Creates an identity quaternion\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns an identity quaternion\n     */\n    function identity(dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 1;\n        return newDst;\n    }\n    const tempVec3 = vec3.create();\n    const xUnitVec3 = vec3.create();\n    const yUnitVec3 = vec3.create();\n    /**\n     * Computes a quaternion to represent the shortest rotation from one vector to another.\n     *\n     * @param aUnit - the start vector\n     * @param bUnit - the end vector\n     * @param dst - quaternion to hold result. If not passed in a new one is created.\n     * @returns the result\n     */\n    function rotationTo(aUnit, bUnit, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const dot = vec3.dot(aUnit, bUnit);\n        if (dot < -0.999999) {\n            vec3.cross(xUnitVec3, aUnit, tempVec3);\n            if (vec3.len(tempVec3) < 0.000001) {\n                vec3.cross(yUnitVec3, aUnit, tempVec3);\n            }\n            vec3.normalize(tempVec3, tempVec3);\n            fromAxisAngle(tempVec3, Math.PI, newDst);\n            return newDst;\n        }\n        else if (dot > 0.999999) {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n            newDst[3] = 1;\n            return newDst;\n        }\n        else {\n            vec3.cross(aUnit, bUnit, tempVec3);\n            newDst[0] = tempVec3[0];\n            newDst[1] = tempVec3[1];\n            newDst[2] = tempVec3[2];\n            newDst[3] = 1 + dot;\n            return normalize(newDst, newDst);\n        }\n    }\n    const tempQuat1 = new Ctor(4);\n    const tempQuat2 = new Ctor(4);\n    /**\n     * Performs a spherical linear interpolation with two control points\n     *\n     * @param a - the first quaternion\n     * @param b - the second quaternion\n     * @param c - the third quaternion\n     * @param d - the fourth quaternion\n     * @param t - Interpolation coefficient 0 to 1\n     * @returns result\n     */\n    function sqlerp(a, b, c, d, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        slerp(a, d, t, tempQuat1);\n        slerp(b, c, t, tempQuat2);\n        slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), newDst);\n        return newDst;\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        fromAxisAngle,\n        toAxisAngle,\n        angle,\n        multiply,\n        mul,\n        rotateX,\n        rotateY,\n        rotateZ,\n        slerp,\n        inverse,\n        conjugate,\n        fromMat,\n        fromEuler,\n        copy,\n        clone,\n        add,\n        subtract,\n        sub,\n        mulScalar,\n        scale,\n        divScalar,\n        dot,\n        lerp,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        normalize,\n        equalsApproximately,\n        equals,\n        identity,\n        rotationTo,\n        sqlerp,\n    };\n}\nconst cache$1 = new Map();\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nfunction getAPI$1(Ctor) {\n    let api = cache$1.get(Ctor);\n    if (!api) {\n        api = getAPIImpl$1(Ctor);\n        cache$1.set(Ctor, api);\n    }\n    return api;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Generates am typed API for Vec4\n * */\nfunction getAPIImpl(Ctor) {\n    /**\n     * Creates a vec4; may be called with x, y, z to set initial values.\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param w - Initial w value.\n     * @returns the created vector\n     */\n    function create(x, y, z, w) {\n        const newDst = new Ctor(4);\n        if (x !== undefined) {\n            newDst[0] = x;\n            if (y !== undefined) {\n                newDst[1] = y;\n                if (z !== undefined) {\n                    newDst[2] = z;\n                    if (w !== undefined) {\n                        newDst[3] = w;\n                    }\n                }\n            }\n        }\n        return newDst;\n    }\n    /**\n     * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n     * @param x - Initial x value.\n     * @param y - Initial y value.\n     * @param z - Initial z value.\n     * @param z - Initial w value.\n     * @returns the created vector\n     */\n    const fromValues = create;\n    /**\n     * Sets the values of a Vec4\n     * Also see {@link vec4.create} and {@link vec4.copy}\n     *\n     * @param x first value\n     * @param y second value\n     * @param z third value\n     * @param w fourth value\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector with its elements set.\n     */\n    function set(x, y, z, w, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = x;\n        newDst[1] = y;\n        newDst[2] = z;\n        newDst[3] = w;\n        return newDst;\n    }\n    /**\n     * Applies Math.ceil to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the ceil of each element of v.\n     */\n    function ceil(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.ceil(v[0]);\n        newDst[1] = Math.ceil(v[1]);\n        newDst[2] = Math.ceil(v[2]);\n        newDst[3] = Math.ceil(v[3]);\n        return newDst;\n    }\n    /**\n     * Applies Math.floor to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the floor of each element of v.\n     */\n    function floor(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.floor(v[0]);\n        newDst[1] = Math.floor(v[1]);\n        newDst[2] = Math.floor(v[2]);\n        newDst[3] = Math.floor(v[3]);\n        return newDst;\n    }\n    /**\n     * Applies Math.round to each element of vector\n     * @param v - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the round of each element of v.\n     */\n    function round(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.round(v[0]);\n        newDst[1] = Math.round(v[1]);\n        newDst[2] = Math.round(v[2]);\n        newDst[3] = Math.round(v[3]);\n        return newDst;\n    }\n    /**\n     * Clamp each element of vector between min and max\n     * @param v - Operand vector.\n     * @param max - Min value, default 0\n     * @param min - Max value, default 1\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that the clamped value of each element of v.\n     */\n    function clamp(v, min = 0, max = 1, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.min(max, Math.max(min, v[0]));\n        newDst[1] = Math.min(max, Math.max(min, v[1]));\n        newDst[2] = Math.min(max, Math.max(min, v[2]));\n        newDst[3] = Math.min(max, Math.max(min, v[3]));\n        return newDst;\n    }\n    /**\n     * Adds two vectors; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a and b.\n     */\n    function add(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + b[0];\n        newDst[1] = a[1] + b[1];\n        newDst[2] = a[2] + b[2];\n        newDst[3] = a[3] + b[3];\n        return newDst;\n    }\n    /**\n     * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param scale - Amount to scale b\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the sum of a + b * scale.\n     */\n    function addScaled(a, b, scale, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + b[0] * scale;\n        newDst[1] = a[1] + b[1] * scale;\n        newDst[2] = a[2] + b[2] * scale;\n        newDst[3] = a[3] + b[3] * scale;\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    function subtract(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] - b[0];\n        newDst[1] = a[1] - b[1];\n        newDst[2] = a[2] - b[2];\n        newDst[3] = a[3] - b[3];\n        return newDst;\n    }\n    /**\n     * Subtracts two vectors.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A vector that is the difference of a and b.\n     */\n    const sub = subtract;\n    /**\n     * Check if 2 vectors are approximately equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are approximately equal\n     */\n    function equalsApproximately(a, b) {\n        return Math.abs(a[0] - b[0]) < EPSILON &&\n            Math.abs(a[1] - b[1]) < EPSILON &&\n            Math.abs(a[2] - b[2]) < EPSILON &&\n            Math.abs(a[3] - b[3]) < EPSILON;\n    }\n    /**\n     * Check if 2 vectors are exactly equal\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns true if vectors are exactly equal\n     */\n    function equals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficient.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The linear interpolated result.\n     */\n    function lerp(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + t * (b[0] - a[0]);\n        newDst[1] = a[1] + t * (b[1] - a[1]);\n        newDst[2] = a[2] + t * (b[2] - a[2]);\n        newDst[3] = a[3] + t * (b[3] - a[3]);\n        return newDst;\n    }\n    /**\n     * Performs linear interpolation on two vectors.\n     * Given vectors a and b and interpolation coefficient vector t, returns\n     * a + t * (b - a).\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param t - Interpolation coefficients vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns the linear interpolated result.\n     */\n    function lerpV(a, b, t, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] + t[0] * (b[0] - a[0]);\n        newDst[1] = a[1] + t[1] * (b[1] - a[1]);\n        newDst[2] = a[2] + t[2] * (b[2] - a[2]);\n        newDst[3] = a[3] + t[3] * (b[3] - a[3]);\n        return newDst;\n    }\n    /**\n     * Return max values of two vectors.\n     * Given vectors a and b returns\n     * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The max components vector.\n     */\n    function max(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.max(a[0], b[0]);\n        newDst[1] = Math.max(a[1], b[1]);\n        newDst[2] = Math.max(a[2], b[2]);\n        newDst[3] = Math.max(a[3], b[3]);\n        return newDst;\n    }\n    /**\n     * Return min values of two vectors.\n     * Given vectors a and b returns\n     * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The min components vector.\n     */\n    function min(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = Math.min(a[0], b[0]);\n        newDst[1] = Math.min(a[1], b[1]);\n        newDst[2] = Math.min(a[2], b[2]);\n        newDst[3] = Math.min(a[3], b[3]);\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function mulScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] * k;\n        newDst[1] = v[1] * k;\n        newDst[2] = v[2] * k;\n        newDst[3] = v[3] * k;\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by a scalar. (same as mulScalar)\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    const scale = mulScalar;\n    /**\n     * Divides a vector by a scalar.\n     * @param v - The vector.\n     * @param k - The scalar.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The scaled vector.\n     */\n    function divScalar(v, k, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0] / k;\n        newDst[1] = v[1] / k;\n        newDst[2] = v[2] / k;\n        newDst[3] = v[3] / k;\n        return newDst;\n    }\n    /**\n     * Inverse a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    function inverse(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = 1 / v[0];\n        newDst[1] = 1 / v[1];\n        newDst[2] = 1 / v[2];\n        newDst[3] = 1 / v[3];\n        return newDst;\n    }\n    /**\n     * Invert a vector. (same as inverse)\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The inverted vector.\n     */\n    const invert = inverse;\n    /**\n     * Computes the dot product of two vectors\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @returns dot product\n     */\n    function dot(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n    }\n    /**\n     * Computes the length of vector\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    function length(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    }\n    /**\n     * Computes the length of vector (same as length)\n     * @param v - vector.\n     * @returns length of vector.\n     */\n    const len = length;\n    /**\n     * Computes the square of the length of vector\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    function lengthSq(v) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n    }\n    /**\n     * Computes the square of the length of vector (same as lengthSq)\n     * @param v - vector.\n     * @returns square of the length of vector.\n     */\n    const lenSq = lengthSq;\n    /**\n     * Computes the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    function distance(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        const dw = a[3] - b[3];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n    }\n    /**\n     * Computes the distance between 2 points (same as distance)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns distance between a and b\n     */\n    const dist = distance;\n    /**\n     * Computes the square of the distance between 2 points\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    function distanceSq(a, b) {\n        const dx = a[0] - b[0];\n        const dy = a[1] - b[1];\n        const dz = a[2] - b[2];\n        const dw = a[3] - b[3];\n        return dx * dx + dy * dy + dz * dz + dw * dw;\n    }\n    /**\n     * Computes the square of the distance between 2 points (same as distanceSq)\n     * @param a - vector.\n     * @param b - vector.\n     * @returns square of the distance between a and b\n     */\n    const distSq = distanceSq;\n    /**\n     * Divides a vector by its Euclidean length and returns the quotient.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The normalized vector.\n     */\n    function normalize(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n        if (len > 0.00001) {\n            newDst[0] = v0 / len;\n            newDst[1] = v1 / len;\n            newDst[2] = v2 / len;\n            newDst[3] = v3 / len;\n        }\n        else {\n            newDst[0] = 0;\n            newDst[1] = 0;\n            newDst[2] = 0;\n            newDst[3] = 0;\n        }\n        return newDst;\n    }\n    /**\n     * Negates a vector.\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns -v.\n     */\n    function negate(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = -v[0];\n        newDst[1] = -v[1];\n        newDst[2] = -v[2];\n        newDst[3] = -v[3];\n        return newDst;\n    }\n    /**\n     * Copies a vector. (same as {@link vec4.clone})\n     * Also see {@link vec4.create} and {@link vec4.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    function copy(v, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = v[0];\n        newDst[1] = v[1];\n        newDst[2] = v[2];\n        newDst[3] = v[3];\n        return newDst;\n    }\n    /**\n     * Clones a vector. (same as {@link vec4.copy})\n     * Also see {@link vec4.create} and {@link vec4.set}\n     * @param v - The vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns A copy of v.\n     */\n    const clone = copy;\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    function multiply(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] * b[0];\n        newDst[1] = a[1] * b[1];\n        newDst[2] = a[2] * b[2];\n        newDst[3] = a[3] * b[3];\n        return newDst;\n    }\n    /**\n     * Multiplies a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as mul)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of products of entries of a and b.\n     */\n    const mul = multiply;\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length.\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    function divide(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = a[0] / b[0];\n        newDst[1] = a[1] / b[1];\n        newDst[2] = a[2] / b[2];\n        newDst[3] = a[3] / b[3];\n        return newDst;\n    }\n    /**\n     * Divides a vector by another vector (component-wise); assumes a and\n     * b have the same length. (same as divide)\n     * @param a - Operand vector.\n     * @param b - Operand vector.\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The vector of quotients of entries of a and b.\n     */\n    const div = divide;\n    /**\n     * Zero's a vector\n     * @param dst - vector to hold result. If not passed in a new one is created.\n     * @returns The zeroed vector.\n     */\n    function zero(dst) {\n        const newDst = (dst ?? new Ctor(4));\n        newDst[0] = 0;\n        newDst[1] = 0;\n        newDst[2] = 0;\n        newDst[3] = 0;\n        return newDst;\n    }\n    /**\n     * transform vec4 by 4x4 matrix\n     * @param v - the vector\n     * @param m - The matrix.\n     * @param dst - optional vec4 to store result. If not passed a new one is created.\n     * @returns the transformed vector\n     */\n    function transformMat4(v, m, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        const x = v[0];\n        const y = v[1];\n        const z = v[2];\n        const w = v[3];\n        newDst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n        newDst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n        newDst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n        newDst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n        return newDst;\n    }\n    /**\n     * Treat a 4D vector as a direction and set it's length\n     *\n     * @param a The vec4 to lengthen\n     * @param len The length of the resulting vector\n     * @returns The lengthened vector\n     */\n    function setLength(a, len, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        normalize(a, newDst);\n        return mulScalar(newDst, len, newDst);\n    }\n    /**\n     * Ensure a vector is not longer than a max length\n     *\n     * @param a The vec4 to limit\n     * @param maxLen The longest length of the resulting vector\n     * @returns The vector, shortened to maxLen if it's too long\n     */\n    function truncate(a, maxLen, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        if (length(a) > maxLen) {\n            return setLength(a, maxLen, newDst);\n        }\n        return copy(a, newDst);\n    }\n    /**\n     * Return the vector exactly between 2 endpoint vectors\n     *\n     * @param a Endpoint 1\n     * @param b Endpoint 2\n     * @returns The vector exactly residing between endpoints 1 and 2\n     */\n    function midpoint(a, b, dst) {\n        const newDst = (dst ?? new Ctor(4));\n        return lerp(a, b, 0.5, newDst);\n    }\n    return {\n        create,\n        fromValues,\n        set,\n        ceil,\n        floor,\n        round,\n        clamp,\n        add,\n        addScaled,\n        subtract,\n        sub,\n        equalsApproximately,\n        equals,\n        lerp,\n        lerpV,\n        max,\n        min,\n        mulScalar,\n        scale,\n        divScalar,\n        inverse,\n        invert,\n        dot,\n        length,\n        len,\n        lengthSq,\n        lenSq,\n        distance,\n        dist,\n        distanceSq,\n        distSq,\n        normalize,\n        negate,\n        copy,\n        clone,\n        multiply,\n        mul,\n        divide,\n        div,\n        zero,\n        transformMat4,\n        setLength,\n        truncate,\n        midpoint,\n    };\n}\nconst cache = new Map();\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `newDst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nfunction getAPI(Ctor) {\n    let api = cache.get(Ctor);\n    if (!api) {\n        api = getAPIImpl(Ctor);\n        cache.set(Ctor, api);\n    }\n    return api;\n}\n\n/**\n * Generate wgpu-matrix API for type\n */\nfunction wgpuMatrixAPI(Mat3Ctor, Mat4Ctor, QuatCtor, Vec2Ctor, Vec3Ctor, Vec4Ctor) {\n    return {\n        /** @namespace mat4 */\n        mat4: getAPI$2(Mat3Ctor),\n        /** @namespace mat3 */\n        mat3: getAPI$4(Mat4Ctor),\n        /** @namespace quat */\n        quat: getAPI$1(QuatCtor),\n        /** @namespace vec2 */\n        vec2: getAPI$5(Vec2Ctor),\n        /** @namespace vec3 */\n        vec3: getAPI$3(Vec3Ctor),\n        /** @namespace vec4 */\n        vec4: getAPI(Vec4Ctor),\n    };\n}\nconst { \n/** @namespace */\nmat4, \n/** @namespace */\nmat3, \n/** @namespace */\nquat, \n/** @namespace */\nvec2, \n/** @namespace */\nvec3, \n/** @namespace */\nvec4, } = wgpuMatrixAPI(Float32Array, Float32Array, Float32Array, Float32Array, Float32Array, Float32Array);\nconst { \n/** @namespace */\nmat4: mat4d, \n/** @namespace */\nmat3: mat3d, \n/** @namespace */\nquat: quatd, \n/** @namespace */\nvec2: vec2d, \n/** @namespace */\nvec3: vec3d, \n/** @namespace */\nvec4: vec4d, } = wgpuMatrixAPI(Float64Array, Float64Array, Float64Array, Float64Array, Float64Array, Float64Array);\nconst { \n/** @namespace */\nmat4: mat4n, \n/** @namespace */\nmat3: mat3n, \n/** @namespace */\nquat: quatn, \n/** @namespace */\nvec2: vec2n, \n/** @namespace */\nvec3: vec3n, \n/** @namespace */\nvec4: vec4n, } = wgpuMatrixAPI(ZeroArray, Array, Array, Array, Array, Array);\n\n\n//# sourceMappingURL=wgpu-matrix.module.js.map\n\n\n//# sourceURL=webpack://game_engine/./node_modules/wgpu-matrix/dist/3.x/wgpu-matrix.module.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;